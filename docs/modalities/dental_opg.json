[
    {
        "level": "meta-data-id",
        "title": "id",
        "content-type": "rawtext",
        "content": "dental_opg"
    },
    {
        "level": "meta-data-parents",
        "title": "parents",
        "content-type": "list_of_strings",
        "content": [
            "Dental", "X-Ray"
        ]
    },
    {
        "level": "meta-data-title",
        "title": "title",
        "content-type": "rawtext",
        "content": "Panoramic Radiography"
    },
    {
        "level": "meta-data-acronyms",
        "title": "acronyms",
        "content-type": "list_of_strings",
        "content": [
            "OPG",
            "",
            "",
            ""
        ]
    },
    {
        "level": "meta-data-shortDescription",
        "title": "shortDescription",
        "content-type": "rawtext",
        "content": "OPG imaging uses a rotating X-ray beam and a synchronized film or sensor to capture a panoramic 2D view of the entire oral and maxillofacial region in a single scan.\n"
    },
    {
        "level": "4",
        "title": "Data Type & File Format",
        "content-type": "markdown",
        "content": " "
    },
    {
        "level": "4.1",
        "title": "Primary File Format(s)",
        "content-type": "markdown",
        "content": "DICOM (.dcm)\tJPEG (Joint Photographic Experts Group)\tPNG (Portable Network Graphics)\tTIFF (Tagged Image File Format)\tBMP (Bitmap)\tPDF (Portable Document Format) \tGIF (Graphics Interchange Format)\tRAW\tSVG (Scalable Vector Graphics)\tWEBP"
    },
    {
        "level": "4.2",
        "title": "Data Type",
        "content-type": "markdown",
        "content": "Grayscale"
    },
    {
        "level": "4.3",
        "title": "Related Data Types (parent type)",
        "content-type": "markdown",
        "content": "X-Ray"
    },
    {
        "level": "4.4",
        "title": "Standard Storage Format (which one in 4.1)",
        "content-type": "markdown",
        "content": "DICOM (.dcm)"
    },
    {
        "level": "4.5.",
        "title": "Conversion Solutions + Reference",
        "content-type": "table",
        "content": [
            [
                "conversion_from",
                "conversion_to",
                "Methodology",
                "Tools and Libraries Used",
                " How the Code Works",
                "Reference",
                " "
            ],
            [
                "JPEG (Joint Photographic Experts Group)",
                "DICOM (.dcm)",
                "The code follows these steps:  Load an Image: The script loads an image file (e.g., PNG, BMP) using the Pillow library.  Convert Image Formats: If the image is in PNG or BMP format, it is converted to RGB format to ensure compatibility.  Convert Image Modes: The image is processed based on its pixel mode (e.g., grayscale, RGB, RGBA) and converted into a NumPy array.  Create DICOM Metadata: A DICOM dataset is created from scratch, and metadata (e.g., patient name, image dimensions, pixel data) is added to the dataset.  Save as DICOM: The final DICOM file is saved with a unique filename.",
                "The following Python libraries are used in this script:  pydicom:  A library for working with DICOM files.  Used to create and manipulate DICOM datasets and metadata.  Key functionalities: Creating DICOM files, setting metadata, and saving files.  Pillow (PIL):  A Python Imaging Library used for opening, manipulating, and saving image files.  Used to load the input image, convert formats, and extract pixel data.  numpy:  A library for numerical computing in Python.  Used to convert image pixel data into a NumPy array for processing.  uuid:  A library for generating unique identifiers.  Used to create a unique filename for the output DICOM file.",
                "Here\u2019s a step-by-step breakdown of the code:  Step 1: Load the Input Image python Copy img = Image.open(INPUT_FILE) width, height = img.size print(\"File format is {} and size: {}, {}\".format(img.format, width, height)) The input image is loaded using Pillow's Image.open() method.  The image format (e.g., PNG, BMP) and dimensions (width, height) are printed.  Step 2: Convert Image Formats python Copy if img.format == 'PNG' or img.format == 'BMP':     img = img.convert('RGB') If the image is in PNG or BMP format, it is converted to RGB format using img.convert('RGB').  Step 3: Convert Image Modes python Copy if img.mode == 'L':     np_frame = numpy.array(img.getdata(), dtype=numpy.uint8)     np_frame = np_frame.reshape((height, width))     ds.PixelData = np_frame.tobytes() elif img.mode == 'RGBA' or img.mode == 'RGB':     np_frame = numpy.array(img.getdata(), dtype=numpy.uint8)     np_frame = np_frame.reshape((height, width, -1)) else:     print(\"Unknown image mode\")     return The image mode (e.g., grayscale, RGB, RGBA) is checked.  For grayscale (L mode), the image is converted to a 2D NumPy array.  For RGB or RGBA modes, the image is converted to a 3D NumPy array.  The pixel data is reshaped to match the image dimensions.  Step 4: Create DICOM Metadata python Copy ds = Dataset() ds.file_meta = Dataset() ds.file_meta.TransferSyntaxUID = pydicom.uid.ExplicitVRLittleEndian ds.file_meta.MediaStorageSOPClassUID = '1.2.840.10008.5.1.4.1.1.1.1' ds.file_meta.MediaStorageSOPInstanceUID = \"1.2.3\" ds.file_meta.ImplementationClassUID = \"1.2.3.4\"  ds.PatientName = 'Created'  ds.Rows = img.height ds.Columns = img.width ds.PhotometricInterpretation = \"YBR_FULL_422\" if np_frame.shape[1] == 3:     ds.SamplesPerPixel = 3 else:     ds.SamplesPerPixel = 1 ds.BitsStored = 8 ds.BitsAllocated = 8 ds.HighBit = 7 ds.PixelRepresentation = 0 ds.PlanarConfiguration = 0 ds.NumberOfFrames = 1  ds.SOPClassUID = generate_uid() ds.SOPInstanceUID = generate_uid() ds.StudyInstanceUID = generate_uid() ds.SeriesInstanceUID = generate_uid()  ds.PixelData = np_frame A new DICOM dataset (ds) is created using pydicom.  Metadata is added to the dataset, including:  Transfer syntax, SOP class, and instance UIDs.  Patient name (set to 'Created').  Image dimensions (rows and columns).  Photometric interpretation (e.g., YBR_FULL_422 for color images).  Pixel data properties (e.g., bits stored, bits allocated).  Unique identifiers (UIDs) are generated for the SOP class, instance, study, and series.  Step 5: Save as DICOM python Copy ds.is_little_endian = True ds.is_implicit_VR = False  ds.save_as(dicomized_filename, write_like_original=False) The dataset is configured to use little-endian byte order and explicit VR (Value Representation).  The DICOM file is saved with a unique filename generated using uuid.uuid4()",
                "https://github.com/jwitos/JPG-to-DICOM/blob/master/jpeg-to-dicom.py",
                ""
            ],
            [
                "PNG (Portable Network Graphics)",
                "DICOM (.dcm)",
                "The code follows these steps:  Load an Image: The script loads an image file (e.g., PNG, BMP) using the Pillow library.  Convert Image Formats: If the image is in PNG or BMP format, it is converted to RGB format to ensure compatibility.  Convert Image Modes: The image is processed based on its pixel mode (e.g., grayscale, RGB, RGBA) and converted into a NumPy array.  Create DICOM Metadata: A DICOM dataset is created from scratch, and metadata (e.g., patient name, image dimensions, pixel data) is added to the dataset.  Save as DICOM: The final DICOM file is saved with a unique filename.",
                "The following Python libraries are used in this script:  pydicom:  A library for working with DICOM files.  Used to create and manipulate DICOM datasets and metadata.  Key functionalities: Creating DICOM files, setting metadata, and saving files.  Pillow (PIL):  A Python Imaging Library used for opening, manipulating, and saving image files.  Used to load the input image, convert formats, and extract pixel data.  numpy:  A library for numerical computing in Python.  Used to convert image pixel data into a NumPy array for processing.  uuid:  A library for generating unique identifiers.  Used to create a unique filename for the output DICOM file.",
                "Here\u2019s a step-by-step breakdown of the code:  Step 1: Load the Input Image python Copy img = Image.open(INPUT_FILE) width, height = img.size print(\"File format is {} and size: {}, {}\".format(img.format, width, height)) The input image is loaded using Pillow's Image.open() method.  The image format (e.g., PNG, BMP) and dimensions (width, height) are printed.  Step 2: Convert Image Formats python Copy if img.format == 'PNG' or img.format == 'BMP':     img = img.convert('RGB') If the image is in PNG or BMP format, it is converted to RGB format using img.convert('RGB').  Step 3: Convert Image Modes python Copy if img.mode == 'L':     np_frame = numpy.array(img.getdata(), dtype=numpy.uint8)     np_frame = np_frame.reshape((height, width))     ds.PixelData = np_frame.tobytes() elif img.mode == 'RGBA' or img.mode == 'RGB':     np_frame = numpy.array(img.getdata(), dtype=numpy.uint8)     np_frame = np_frame.reshape((height, width, -1)) else:     print(\"Unknown image mode\")     return The image mode (e.g., grayscale, RGB, RGBA) is checked.  For grayscale (L mode), the image is converted to a 2D NumPy array.  For RGB or RGBA modes, the image is converted to a 3D NumPy array.  The pixel data is reshaped to match the image dimensions.  Step 4: Create DICOM Metadata python Copy ds = Dataset() ds.file_meta = Dataset() ds.file_meta.TransferSyntaxUID = pydicom.uid.ExplicitVRLittleEndian ds.file_meta.MediaStorageSOPClassUID = '1.2.840.10008.5.1.4.1.1.1.1' ds.file_meta.MediaStorageSOPInstanceUID = \"1.2.3\" ds.file_meta.ImplementationClassUID = \"1.2.3.4\"  ds.PatientName = 'Created'  ds.Rows = img.height ds.Columns = img.width ds.PhotometricInterpretation = \"YBR_FULL_422\" if np_frame.shape[1] == 3:     ds.SamplesPerPixel = 3 else:     ds.SamplesPerPixel = 1 ds.BitsStored = 8 ds.BitsAllocated = 8 ds.HighBit = 7 ds.PixelRepresentation = 0 ds.PlanarConfiguration = 0 ds.NumberOfFrames = 1  ds.SOPClassUID = generate_uid() ds.SOPInstanceUID = generate_uid() ds.StudyInstanceUID = generate_uid() ds.SeriesInstanceUID = generate_uid()  ds.PixelData = np_frame A new DICOM dataset (ds) is created using pydicom.  Metadata is added to the dataset, including:  Transfer syntax, SOP class, and instance UIDs.  Patient name (set to 'Created').  Image dimensions (rows and columns).  Photometric interpretation (e.g., YBR_FULL_422 for color images).  Pixel data properties (e.g., bits stored, bits allocated).  Unique identifiers (UIDs) are generated for the SOP class, instance, study, and series.  Step 5: Save as DICOM python Copy ds.is_little_endian = True ds.is_implicit_VR = False  ds.save_as(dicomized_filename, write_like_original=False) The dataset is configured to use little-endian byte order and explicit VR (Value Representation).  The DICOM file is saved with a unique filename generated using uuid.uuid4()",
                "https://github.com/jwitos/JPG-to-DICOM/blob/master/jpeg-to-dicom.py",
                ""
            ],
            [
                "TIFF (Tagged Image File Format)",
                "DICOM (.dcm)",
                "The code follows these steps:  Load Image Formats: The script identifies supported input and output image formats.  Process Conversion: For each input format, the script attempts to convert it into all supported output formats.  Save Output: The converted files are saved, and temporary files are deleted if specified.  Handle Vector and Raster Images: The script distinguishes between vector and raster images and applies appropriate conversion options.",
                "The following tools and libraries are used in this script:  Aspose.Imaging:  A powerful library for image processing and conversion.  Supports a wide range of formats, including TIFF, PNG, BMP, JPEG, DICOM, and more.  Used for loading, converting, and saving images.  os:  A Python standard library for interacting with the operating system.  Used for file path manipulation and checking file existence.  Environment Variables:  The script uses environment variables (TEMPLATE_DIR and SAVE_OUTPUT) to configure the input/output directories and whether to delete output files.",
                "Here\u2019s a step-by-step breakdown of the code:  Step 1: Set Up Directories python Copy if 'TEMPLATE_DIR' in os.environ:     templates_folder = os.environ['TEMPLATE_DIR'] else:     templates_folder = r\"C:\\Users\\USER\\Downloads\\templates\"  delete_output = 'SAVE_OUTPUT' not in os.environ The script checks if the TEMPLATE_DIR environment variable is set. If not, it defaults to a local directory (C:\\Users\\USER\\Downloads\\templates).  The delete_output flag determines whether to delete the output files after conversion (based on the SAVE_OUTPUT environment variable).  Step 2: Define Conversion Function python Copy def process_convertion():     import_formats, export_formats = get_available_image_formats()          for import_key, import_value in import_formats.items():         format_ext = import_key         input_file = os.path.join(templates_folder, f\"template.{format_ext}\")                  if not os.path.exists(input_file):             continue                  for export_key, export_value in export_formats.items():             output_file = os.path.join(templates_folder, f\"convert-{format_ext}-to-{export_key}.{export_key}\")             print(\"Processing conversion:\" + output_file)             with Image.load(input_file) as image:                 export_options = export_value.clone()                 if is_assignable(image, VectorImage):                     rasterization_options = import_value                     rasterization_options.page_width = float(image.width)                     rasterization_options.page_height = float(image.height)                     export_options.vector_rasterization_options = rasterization_options                  image.save(output_file, export_options)              if delete_output:                 os.remove(output_file) The process_convertion() function performs the actual conversion.  It retrieves the available input and output formats using get_available_image_formats().  For each input format, it checks if a corresponding template file exists (e.g., template.tiff).  For each output format, it creates an output file (e.g., convert-tiff-to-dicom.dicom).  The image is loaded using Image.load(), and conversion options are applied.  If the image is a vector image, rasterization options are configured.  The converted image is saved, and the output file is deleted if delete_output is True.  Step 3: Define Supported Formats python Copy def get_available_image_formats():     obj_init = Jpeg2000Options()     obj_init.codec = Jpeg2000Codec.J2K     obj_init2 = Jpeg2000Options()     obj_init2.codec = Jpeg2000Codec.JP2     obj_init3 = PngOptions()     obj_init3.color_type = PngColorType.TRUECOLOR_WITH_ALPHA     obj_init4 = {}     obj_init4[\"bmp\"] = BmpOptions()     obj_init4[\"gif\"] = GifOptions()     obj_init4[\"dicom\"] = DicomOptions()     obj_init4[\"jpg\"] = JpegOptions()     obj_init4[\"jpeg\"] = JpegOptions()     obj_init4[\"jpeg2000\"] = Jpeg2000Options()     obj_init4[\"j2k\"] = obj_init     obj_init4[\"jp2\"] = obj_init2     obj_init4[\"png\"] = obj_init3     obj_init4[\"apng\"] = ApngOptions()     obj_init4[\"tiff\"] = TiffOptions(TiffExpectedFormat.DEFAULT)     obj_init4[\"tif\"] = TiffOptions(TiffExpectedFormat.DEFAULT)     obj_init4[\"tga\"] = TgaOptions()     obj_init4[\"webp\"] = WebPOptions()     obj_init4[\"ico\"] = IcoOptions(FileFormat.PNG, 24)     raster_formats_that_support_export_and_import = obj_init4          obj_init5 = EmfOptions()     obj_init5.compress = True     obj_init6 = WmfOptions()     obj_init6.compress = True     obj_init7 = SvgOptions()     obj_init7.compress = True     obj_init8 = {}     obj_init8[\"emf\"] = (EmfOptions(), EmfRasterizationOptions())     obj_init8[\"svg\"] = (SvgOptions(), SvgRasterizationOptions())     obj_init8[\"wmf\"] = (WmfOptions(), WmfRasterizationOptions())     obj_init8[\"emz\"] = (obj_init5, EmfRasterizationOptions())     obj_init8[\"wmz\"] = (obj_init6, WmfRasterizationOptions())     obj_init8[\"svgz\"] = (obj_init7, SvgRasterizationOptions())     vector_formats_that_support_export_and_import = obj_init8          obj_init9 = DxfOptions()     obj_init9.text_as_lines = True     obj_init9.convert_text_beziers = True     obj_init10 = {}     obj_init10[\"psd\"] = PsdOptions()     obj_init10[\"dxf\"] = obj_init9     obj_init10[\"pdf\"] = PdfOptions()     obj_init10[\"html\"] = Html5CanvasOptions()     formats_only_for_export = obj_init10          obj_init11 = {}     obj_init11[\"djvu\"] = None     obj_init11[\"dng\"] = None     obj_init11[\"dib\"] = None     formats_only_for_import = obj_init11          obj_init12 = {}     obj_init12[\"eps\"] = EpsRasterizationOptions()     obj_init12[\"cdr\"] = CdrRasterizationOptions()     obj_init12[\"cmx\"] = CmxRasterizationOptions()     obj_init12[\"otg\"] = OtgRasterizationOptions()     obj_init12[\"odg\"] = OdgRasterizationOptions()     vector_formats_only_for_import = obj_init12          # Get total set of formats to what we can export images     export_formats = {k: v[0] for k, v in vector_formats_that_support_export_and_import.items()}     export_formats.update(formats_only_for_export)     export_formats.update(raster_formats_that_support_export_and_import)          # Get total set of formats that can be loaded     import_formats = {k : VectorRasterizationOptions() for k in formats_only_for_import}     import_formats.update(vector_formats_only_for_import)     import_formats.update({k : v[1] for k, v in vector_formats_that_support_export_and_import.items()})          return import_formats, export_formats The get_available_image_formats() function defines the supported input and output formats.  It categorizes formats into raster, vector, and special formats (e.g., PDF, HTML).  It returns two dictionaries: import_formats (formats that can be loaded) and export_formats (formats that can be saved).  Step 4: Run the Conversion python Copy # run process_convertion() The script executes the process_convertion() function to perform the conversions.",
                "https://products.aspose.com/imaging/python-net/conversion/tiff-to-dicom/",
                ""
            ],
            [
                "BMP (Bitmap)",
                "DICOM (.dcm)",
                "The code follows these steps:  Load the BMP Image: The script loads a BMP image file from a specified directory.  Set Up DICOM Options: It creates an instance of DicomOptions to configure the output DICOM file.  Save as DICOM: The BMP image is saved as a DICOM file.  Clean Up: The output DICOM file is deleted (optional, for demonstration purposes).",
                "The following tools and libraries are used in this code:  Aspose.Imaging:  A powerful .NET library for image processing and conversion.  Supports a wide range of formats, including BMP, DICOM, PNG, JPEG, and more.  Used for loading, converting, and saving images.  System.IO:  A .NET namespace for file and directory manipulation.  Used for handling file paths and deleting files.",
                "Here\u2019s a step-by-step breakdown of the code:  Step 1: Set Up the Templates Folder csharp Copy string templatesFolder = @\"c:\\Users\\USER\\Downloads\\templates\\\"; The templatesFolder variable specifies the directory where the input BMP file (template.bmp) is located.  You can download the image templates from this GitHub repository and update the path accordingly.  Step 2: Load the BMP Image csharp Copy using (var image = Aspose.Imaging.Image.Load(Path.Combine(templatesFolder, @\"template.bmp\"))) The Image.Load() method loads the BMP image (template.bmp) from the specified directory.  The using statement ensures that the image resources are properly disposed of after use.  Step 3: Set Up DICOM Options csharp Copy var exportOptions = new Aspose.Imaging.ImageOptions.DicomOptions(); An instance of DicomOptions is created to configure the output DICOM file.  This object allows you to customize DICOM-specific settings (e.g., compression, metadata).  Step 4: Save as DICOM csharp Copy image.Save(Path.Combine(templatesFolder, \"output.dicom\"), exportOptions); The image.Save() method saves the BMP image as a DICOM file (output.dicom) in the specified directory.  The exportOptions object is passed to configure the DICOM output.  Step 5: Clean Up csharp Copy File.Delete(Path.Combine(templatesFolder, \"output.dicom\")); The output DICOM file (output.dicom) is deleted after conversion.  This step is optional and can be removed if you want to keep the output file.  4. Key Points Input: The script expects a BMP file (template.bmp) in the specified directory.  Output: A DICOM file (output.dicom) is generated in the same directory.  Aspose.Imaging: The library handles the conversion process seamlessly.  Clean Up: The output file is deleted after conversion (optional).  5. Example Workflow Input: A BMP file (template.bmp).  Output: A DICOM file (output.dicom).  Use Case: This script can be used to convert BMP images into DICOM format for medical imaging applications.  6. Prerequisites Install the Aspose.Imaging library via NuGet:  bash Copy Install-Package Aspose.Imaging Download the image templates from this GitHub repository and update the templatesFolder path.",
                "https://products.aspose.com/imaging/net/conversion/bmp-to-dicom/",
                ""
            ],
            [
                "PDF (Portable Document Format) ",
                "DICOM (.dcm)",
                "Load the PDF File: The PDF file is loaded using the Aspose.PDF library.  Convert PDF Page to JPEG: A specific page of the PDF is converted into a JPEG image using the JpegDevice class.  Load the JPEG Image: The generated JPEG image is loaded using the Aspose.Imaging library.  Save as PSD (or DICOM): The JPEG image is saved in a format compatible with DICOM (e.g., PSD) using the Aspose.Imaging library.",
                "The following libraries are used in this code:  Aspose.PDF:  A .NET library for working with PDF files.  Used to load the PDF file and convert a specific page into an image (JPEG format).  Aspose.Imaging:  A .NET library for image processing and conversion.  Used to load the JPEG image and save it in a format compatible with DICOM (e.g., PSD).  File Formats Supported:  Input Formats: PDF, CGM, EPUB, TeX, PCL, PS, XPS, MD, MHTML, XSLFO, HTML.  Output Formats: Dicom, Jpeg2000, Apng, Psd, Dxf, Wmf, Emz, Wmz, Tga, Svgz.",
                "Here\u2019s a step-by-step breakdown of the code:  Step 1: Load the PDF File csharp Copy var document = new Document(\"input.pdf\"); The Document class from the Aspose.PDF library is used to load the PDF file (input.pdf).  This allows access to the pages and content of the PDF.  Step 2: Convert PDF Page to JPEG csharp Copy var renderer = new JpegDevice(); renderer.Process(document.Pages[1], \"output.jpeg\"); The JpegDevice class is used to convert a specific page of the PDF into a JPEG image.  document.Pages[1] refers to the second page of the PDF (indexing starts from 0).  The resulting JPEG image is saved as output.jpeg.  Step 3: Load the JPEG Image csharp Copy var image = Image.Load(\"output.jpeg\"); The Image.Load() method from the Aspose.Imaging library is used to load the JPEG image (output.jpeg).  This prepares the image for further processing or conversion.  Step 4: Save as PSD (or DICOM-Compatible Format) csharp Copy image.Save(\"output.psd\", new PsdOptions()); The image.Save() method is used to save the JPEG image in a different format (e.g., PSD).  PsdOptions() specifies the settings for saving the image in PSD format.  The resulting file is saved as output.psd.",
                "https://products.aspose.com/total/net/conversion/pdf-to-dicom/",
                ""
            ],
            [
                "GIF (Graphics Interchange Format)",
                "DICOM (.dcm)",
                "The methodology reflects a systematic approach to batch image format conversion, with a focus on flexibility and robustness:  Objective Convert images from one format (e.g., GIF) to another (e.g., DICOM) while supporting a wide range of input and output formats. Design Principles Modularity: Uses separate HashMaps and Lists to categorize formats by capability (load/save, save-only, load-only), making it easy to extend or modify supported formats. Encapsulates format-specific options in ImageOptionsBase subclasses (e.g., DicomOptions), allowing customization per format. Batch Processing: Employs nested loops (forEach and for) to process all possible input-output combinations, enabling bulk conversion without manual intervention. Error Handling: Uses try-with-resources to ensure proper resource management (closing the Image object), preventing memory leaks. Flexibility: Supports conditional logic (e.g., EMF-to-WMF rasterization) to handle special cases, though not needed for GIF-to-DICOM. Workflow Setup: Define the directory and populate format mappings. Input Processing: Iterate over all loadable formats, loading each file (e.g., GIF). Output Generation: For each input, iterate over savable formats, applying appropriate options (e.g., DICOM) and saving the result. Execution: Automate the process for all combinations, logging output paths for verification. Assumptions Input files (e.g., template.gif) exist in the specified directory. The Aspose.Imaging library is licensed and configured correctly to handle DICOM output, which requires specific metadata compliance (not detailed in the code). Limitations Lacks explicit error handling for file-not-found or conversion failures beyond the try block. Assumes all frames in a GIF are converted to a single DICOM file, but multi-frame DICOM specifics (e.g., frame sequence) aren\u2019t customized.",
                "1. Aspose.Imaging for Java Package: com.aspose.imaging Classes Used: Image: Core class for loading and saving images. ImageOptionsBase: Base class for format-specific options (e.g., DicomOptions, GifOptions). Specific options: BmpOptions, GifOptions, DicomOptions, JpegOptions, PngOptions, etc. EmfRasterizationOptions: For vector-to-raster conversions (not directly used for GIF-to-DICOM). Purpose: Provides the functionality to load various image formats, manipulate them, and save them in other formats. Aspose.Imaging supports advanced medical imaging formats like DICOM, making it suitable for this task. Reference: The code comments link to https://apireference.aspose.com/imaging/java/com.aspose.imaging/Image#load-java.lang.String- for documentation. 2. Java Standard Library Package: java.util Classes Used: HashMap: Stores format-option pairs. List and LinkedList: Manage lists of formats. Arrays: Utility for initializing lists (e.g., formatsOnlyForImport). Purpose: Handles data structures for organizing supported formats and iterating over them. Tools > Java Development Kit (JDK): The code is written in Java, requiring a JDK (e.g., version 8 or higher) to compile and run. > Aspose.Imaging JAR Files: Must be included in the project\u2019s classpath to use the Aspose.Imaging library (not explicitly shown but implied by imports).",
                "Step 1: Define the Working Directory Code: String templatesFolder = \"D:\\\\WorkDir\\\\\"; Explanation: The variable templatesFolder is set to a directory path (D:\\\\WorkDir\\\\) where input files are located and output files will be saved. This is the base folder for file operations. Step 2: Initialize Format Support Maps Code: Three collections are created: formatsThatSupportExportAndImport (HashMap): Lists formats that can be both loaded (read) and saved (written), e.g., \"gif\", \"dicom\", \"jpg\". formatsOnlyForExport (HashMap): Lists formats that can only be saved, e.g., \"psd\", \"pdf\". formatsOnlyForImport (List): Lists formats that can only be loaded, e.g., \"djvu\", \"dng\". Details: For \"gif\", a GifOptions object is used; for \"dicom\", a DicomOptions object is used. Each format is paired with an ImageOptionsBase subclass that defines how it\u2019s handled (e.g., PngOptions with TruecolorWithAlpha for PNG). Execution: These maps are populated with supported formats and their respective options. Step 3: Combine Export and Import Formats Code: HashMap<String, ImageOptionsBase> exportToFormats = new HashMap<String, ImageOptionsBase>(formatsOnlyForExport); exportToFormats.putAll(formatsThatSupportExportAndImport); List<String> importFormats = new LinkedList<>(formatsOnlyForImport); importFormats.addAll(formatsThatSupportExportAndImport.keySet()); Explanation: exportToFormats combines all formats that can be saved (both export-only and bidirectional). importFormats combines all formats that can be loaded (import-only and bidirectional). Result: For GIF-to-DICOM, \"gif\" is in importFormats, and \"dicom\" is in exportToFormats. Step 4: Iterate Over Input Formats Code: importFormats.forEach((formatExt) -> { ... }); Explanation: The code loops through each input format in importFormats (e.g., \"gif\"). For each: Constructs an input file path: templatesFolder + \"template.\" + formatExt (e.g., D:\\\\WorkDir\\\\template.gif). Step 5: Iterate Over Output Formats Code: for (Map.Entry<String, ImageOptionsBase> exportFormat : exportToFormats.entrySet()) { ... } Explanation: For each input format (e.g., \"gif\"), it loops through all possible output formats in exportToFormats (e.g., \"dicom\"). Constructs an output file path: e.g., D:\\\\WorkDir\\\\convert\\\\convert-gif-to-dicom.dicom. Prints the output path to the console for tracking. Step 6: Load the Input Image Code: try (Image image = Image.load(inputFile)) { ... } Explanation: Uses Image.load() to read the input file (e.g., template.gif) into an Image object. The try-with-resources ensures the image is closed after processing. Step 7: Configure Export Options Code: ImageOptionsBase exportOptions = exportFormat.getValue().deepClone(); Explanation: Clones the options for the output format (e.g., DicomOptions for \"dicom\") to avoid modifying the original settings. Special Case: If converting from \"emf\" or \"emz\" to a WMF format, it sets rasterization options (page width/height), but this doesn\u2019t apply to GIF-to-DICOM. Step 8: Save the Output Image Code: image.save(outputFile, exportOptions); Explanation: Saves the loaded image (e.g., GIF) to the output file (e.g., DICOM) using the specified options (e.g., DicomOptions). For GIF-to-DICOM, this converts the multi-frame GIF into a DICOM file. Step 9: Repeat for All Combinations Execution: The nested loops process all input-output pairs (e.g., GIF to DICOM, GIF to JPG, etc.), generating converted files in the convert subdirectory.",
                "https://products.aspose.com/imaging/java/conversion/gif-to-dicom/",
                ""
            ],
            [
                "RAW",
                "DICOM (.dcm)",
                "Step1: Convert .raw format to .png Link https://github.com/CrebboElodie/raw-image-converter/blob/main/raw-img-conv_1-2.py This code is designed to convert raw image files from various camera formats (e.g., .RW2, .CR2) into common image formats such as .TIFF, .JPG, and .PNG, while preserving metadata.  Workflow Overview:  The user is prompted to specify input and output formats. The code reads image files from an input directory (/pyin/). Each image is processed using rawpy for high-quality conversion. The processed image is saved with the desired file format using imageio. Metadata is copied using exiftool. Duplicate metadata files are deleted to keep the output clean.  Step 2: Convert .png format to DICOM format: Link https://github.com/jwitos/JPG-to-DICOM/blob/master/jpeg-to-dicom.py The code follows these steps:  Load Image Formats: The script identifies supported input and output image formats.  Process Conversion: For each input format, the script attempts to convert it into all supported output formats.  Save Output: The converted files are saved, and temporary files are deleted if specified.  Handle Vector and Raster Images: The script distinguishes between vector and raster images and applies appropriate conversion options.",
                "Step1: Convert .raw format to .png Link rawpy:  A Python library for reading and processing RAW image files. Used here for reading .RW2, .CR2, and other raw formats and converting them to sRGB color space. imageio:  Handles saving processed images in different formats (e.g., .TIFF, .JPG, .PNG). Provides control over image quality for .JPG. os:  Provides directory navigation, file handling, and command execution. exiftool (via os.system command):  Copies metadata from the original raw file to the converted image file.  Step 2: Convert .png format to DICOM format: Link \"The following tools and libraries are used in this script:  Aspose.Imaging:  A powerful library for image processing and conversion.  Supports a wide range of formats, including TIFF, PNG, BMP, JPEG, DICOM, and more.  Used for loading, converting, and saving images.  os:  A Python standard library for interacting with the operating system.  Used for file path manipulation and checking file existence.  Environment Variables:  The script uses environment variables (TEMPLATE_DIR and SAVE_OUTPUT) to configure the input/output directories and whether to delete output files.  \"",
                "Step1: Convert .raw format to .png Link  Prepare the Environment:  Ensure rawpy, imageio, and exiftool are installed: bash Copy Edit pip install rawpy imageio sudo apt-get install exiftool  # For Linux brew install exiftool          # For macOS Directory Setup:  Create two directories in the same folder as the script: lua Copy Edit /pyin/  --> Place your raw image files here. /pyout/ --> Converted images will be saved here. Running the Script:  Run the script in your terminal or IDE. Follow the prompts: Select the input file format (e.g., .RW2, .CR2, or custom). Choose the output format (e.g., .TIFF, .JPG, .PNG, or custom). For .JPG, specify the desired quality (1-100). Conversion Process:  The script will iterate through the /pyin/ directory, convert each matching file, and save the result in /pyout/. Metadata Handling:  After conversion, metadata will be copied from the original file to the new file using exiftool. Any duplicate metadata files will be deleted. Output Confirmation:  The console will display messages confirming each step of the process.   Step 2: Convert .png format to DICOM format: Link  Here\u2019s a step-by-step breakdown of the code:  Step 1: Load the Input Image python Copy img = Image.open(INPUT_FILE) width, height = img.size print(\"File format is {} and size: {}, {}\".format(img.format, width, height)) The input image is loaded using Pillow's Image.open() method.  The image format (e.g., PNG, BMP) and dimensions (width, height) are printed.  Step 2: Convert Image Formats python Copy if img.format == 'PNG' or img.format == 'BMP':     img = img.convert('RGB') If the image is in PNG or BMP format, it is converted to RGB format using img.convert('RGB').  Step 3: Convert Image Modes python Copy if img.mode == 'L':     np_frame = numpy.array(img.getdata(), dtype=numpy.uint8)     np_frame = np_frame.reshape((height, width))     ds.PixelData = np_frame.tobytes() elif img.mode == 'RGBA' or img.mode == 'RGB':     np_frame = numpy.array(img.getdata(), dtype=numpy.uint8)     np_frame = np_frame.reshape((height, width, -1)) else:     print(\"Unknown image mode\")     return The image mode (e.g., grayscale, RGB, RGBA) is checked.  For grayscale (L mode), the image is converted to a 2D NumPy array.  For RGB or RGBA modes, the image is converted to a 3D NumPy array.  The pixel data is reshaped to match the image dimensions.  Step 4: Create DICOM Metadata python Copy ds = Dataset() ds.file_meta = Dataset() ds.file_meta.TransferSyntaxUID = pydicom.uid.ExplicitVRLittleEndian ds.file_meta.MediaStorageSOPClassUID = '1.2.840.10008.5.1.4.1.1.1.1' ds.file_meta.MediaStorageSOPInstanceUID = \"1.2.3\" ds.file_meta.ImplementationClassUID = \"1.2.3.4\"  ds.PatientName = 'Created'  ds.Rows = img.height ds.Columns = img.width ds.PhotometricInterpretation = \"YBR_FULL_422\" if np_frame.shape[1] == 3:     ds.SamplesPerPixel = 3 else:     ds.SamplesPerPixel = 1 ds.BitsStored = 8 ds.BitsAllocated = 8 ds.HighBit = 7 ds.PixelRepresentation = 0 ds.PlanarConfiguration = 0 ds.NumberOfFrames = 1  ds.SOPClassUID = generate_uid() ds.SOPInstanceUID = generate_uid() ds.StudyInstanceUID = generate_uid() ds.SeriesInstanceUID = generate_uid()  ds.PixelData = np_frame A new DICOM dataset (ds) is created using pydicom.  Metadata is added to the dataset, including:  Transfer syntax, SOP class, and instance UIDs.  Patient name (set to 'Created').  Image dimensions (rows and columns).  Photometric interpretation (e.g., YBR_FULL_422 for color images).  Pixel data properties (e.g., bits stored, bits allocated).  Unique identifiers (UIDs) are generated for the SOP class, instance, study, and series.  Step 5: Save as DICOM python Copy ds.is_little_endian = True ds.is_implicit_VR = False  ds.save_as(dicomized_filename, write_like_original=False) The dataset is configured to use little-endian byte order and explicit VR (Value Representation).  The DICOM file is saved with a unique filename generated using uuid.uuid4()",
                "https://github.com/CrebboElodie/raw-image-converter/blob/main/raw-img-conv_1-2.py, ",
                ""
            ],
            [
                "SVG (Scalable Vector Graphics)",
                "DICOM (.dcm)",
                "Format Cataloging: Categorizes file formats into three groups: Formats that support both import and export (e.g., SVG, DICOM). Formats that can only be exported (e.g., PDF). Formats that can only be imported (e.g., DJVU). Uses HashMap and List to organize these formats with their respective configuration objects. Dynamic File Path Generation: Constructs input and output file paths dynamically based on the format extension and a predefined folder structure (D:\\\\WorkDir\\\\convert\\\\). Iterative Conversion: Uses nested loops to: Load each input file in every supported import format. Convert and save it to every supported export format. For your specific case (SVG to DICOM), it: Loads template.svg using Image.load(). Saves it as convert-svg-to-dicom.dicom using DicomOptions. Error Handling: Employs try-with-resources to ensure proper resource management and exception handling during file operations. Special Cases: Handles specific format conversions (e.g., EMF/EMZ to WMF) with additional rasterization options, showing flexibility for edge cases. Extensibility: Designed to handle multiple formats, making it reusable beyond just SVG-to-DICOM conversion.",
                "Programming Language Java: The code is written in Java, leveraging its object-oriented features and collections framework. Libraries Aspose.Imaging for Java: A commercial library for image processing and format conversion. Key classes used: Image: For loading and saving images. ImageOptionsBase: Base class for format-specific options. Format-specific options: SvgOptions: For handling SVG files. DicomOptions: For DICOM output. Jpeg2000Options, PngOptions, TiffOptions, etc., for other formats. EmfRasterizationOptions: For vector-to-raster conversion in special cases. Provides methods like load() and save() for file operations. Java Standard Library: java.util.HashMap: For mapping formats to their options. java.util.List and java.util.LinkedList: For managing lists of formats. java.util.Arrays: For initializing the formatsOnlyForImport list. java.lang.String: For file path manipulation. Tools No external tools (e.g., IDEs or build systems) are explicitly mentioned, but the code assumes: A Java runtime environment (JRE) to execute. The Aspose.Imaging library JAR file included in the classpath.",
                "Imports The code begins by importing necessary classes from the Aspose.Imaging library: com.aspose.imaging.Image: Core class for loading and manipulating images. com.aspose.imaging.ImageOptionsBase: Base class for image format options. Specific format options like DicomOptions, SvgOptions, Jpeg2000Options, etc., for handling conversions. Enumerations like TiffExpectedFormat and PngColorType for configuring output settings. Variable Setup templatesFolder = \"D:\\\\WorkDir\\\\\": Defines the directory where input files (e.g., template.svg) are located and output files will be saved. Format Dictionaries HashMap formatsThatSupportExportAndImport: Stores file formats that can be both loaded (imported) and saved (exported), such as: \"svg\" \u2192 SvgOptions \"dicom\" \u2192 DicomOptions \"png\" \u2192 PngOptions with TruecolorWithAlpha \"jpeg2000\" \u2192 Jpeg2000Options with codec variants (J2K, Jp2). Uses HashMap<String, ImageOptionsBase> to map format extensions (keys) to their configuration objects (values). Example: formatsThatSupportExportAndImport.put(\"svg\", new SvgOptions());. HashMap formatsOnlyForExport: Stores formats that can only be saved (not loaded), like: \"pdf\" \u2192 PdfOptions \"psd\" \u2192 PsdOptions. List formatsOnlyForImport: A list of formats that can only be loaded (not saved), like \"djvu\", \"dng\", etc. Combined Collections: exportToFormats: Combines formatsThatSupportExportAndImport and formatsOnlyForExport into a single HashMap for all exportable formats. importFormats: Combines formatsOnlyForImport and keys from formatsThatSupportExportAndImport into a list of all importable formats. Main Conversion Logic Lambda Expression importFormats.forEach((formatExt) -> {...}): Iterates over each importable format (e.g., \"svg\", \"jpg\", etc.). Constructs the input file path: templatesFolder + \"template.\" + formatExt (e.g., D:\\\\WorkDir\\\\template.svg). Nested Loop: For each input format (formatExt), iterates over all exportable formats (exportToFormats). Constructs the output file path: Example: D:\\\\WorkDir\\\\convert\\\\convert-svg-to-dicom.dicom. Prints the output file path to the console. Image Loading and Saving: try (Image image = Image.load(inputFile)): Loads the input file (e.g., template.svg) into an Image object using a try-with-resources block (auto-closes the resource). ImageOptionsBase exportOptions = exportFormat.getValue().deepClone(): Creates a deep copy of the export format options (e.g., DicomOptions) to avoid modifying the original. Special Case for EMF/EMZ to WMF: If the input is \"emf\" or \"emz\" and the output is WmfOptions: Configures EmfRasterizationOptions with the image\u2019s width and height for vector-to-raster conversion. Attaches these options to exportOptions. image.save(outputFile, exportOptions): Saves the loaded image to the output file in the specified format (e.g., DICOM).",
                "https://products.aspose.com/imaging/java/conversion/svg-to-dicom/",
                ""
            ],
            [
                "WebP",
                "DICOM (.dcm)",
                "The code follows a straightforward single-file conversion methodology:  Input Specification: Assumes a specific WebP file (template.webp) exists in a predefined directory (templatesFolder). The path is hardcoded, requiring manual adjustment by the user based on their system. Image Processing: Loads the WebP image into memory using Aspose.Imaging\u2019s Image.Load() method. Converts it directly to DICOM format without intermediate steps or additional processing (e.g., resizing, metadata addition). Output Handling: Saves the converted image as output.dicom in the same directory. Immediately deletes the output file, indicating the focus is on demonstrating the conversion capability rather than retaining the result. Resource Management: Uses a using block to ensure proper disposal of the Image object, preventing memory leaks. Simplicity and Focus: The methodology is minimalistic, targeting a single WebP-to-DICOM conversion without batch processing, error handling, or user input customization. It relies on Aspose.Imaging\u2019s built-in functionality to handle format-specific details.",
                "Programming Language C# (.NET): The code is written in C#, a language commonly used with the .NET framework for desktop and enterprise applications. Libraries Aspose.Imaging for .NET: A commercial library for image processing and format conversion in .NET applications. Key classes used: Aspose.Imaging.Image: Base class for loading and saving images. Aspose.Imaging.ImageOptions.DicomOptions: Specific options class for configuring DICOM output. Provides the core functionality for loading WebP and saving as DICOM. Available via NuGet or direct download from Aspose\u2019s website (requires a license for full use). .NET Framework / .NET Core: System: Provides basic utilities (though minimally used here). System.IO: Supplies Path.Combine() for constructing file paths and File.Delete() for file operations. The code is compatible with .NET Framework or .NET Core, depending on the Aspose.Imaging version referenced. Tools Visual Studio (Implied): While not explicitly mentioned, this code is likely intended for use in an IDE like Visual Studio, where .NET projects are typically developed. Compilation and execution require a .NET runtime environment. External Resource: The comment references a GitHub repository (Aspose.Imaging GitHub) for sample templates, implying users need to download and extract these files manually.",
                "Using Directives using Aspose.Imaging; Imports the Aspose.Imaging namespace, which provides classes for image manipulation and format conversion. using System; Provides basic system functionalities (e.g., Console, though not used here). using System.IO; Enables file and path operations (e.g., Path.Combine). using System.Text; Provides text manipulation classes (unused in this code). using System.Collections.Generic; Provides collection classes (unused in this code). Variable Declaration string templatesFolder = @\"c:\\Users\\USER\\Downloads\\templates\\\"; Defines the directory path where the input WebP file (template.webp) is located and where the output DICOM file will be saved. The comment suggests downloading templates from a GitHub repository and updating this path accordingly after unpacking. Image Loading and Conversion Block using (var image = Aspose.Imaging.Image.Load(Path.Combine(templatesFolder, @\"template.webp\"))) Step 1: Load the WebP File Path.Combine(templatesFolder, @\"template.webp\") constructs the full file path (e.g., c:\\Users\\USER\\Downloads\\templates\\template.webp). Aspose.Imaging.Image.Load() loads the WebP image into an Image object. The using statement ensures the Image object is properly disposed of after use (resource management). { Opens the block for operations on the loaded image. var exportOptions = new Aspose.Imaging.ImageOptions.DicomOptions(); Step 2: Create DICOM Options Instantiates a DicomOptions object, which defines the settings for saving the image in DICOM format. No additional configuration (e.g., metadata) is specified here, so default DICOM settings are used. image.Save(Path.Combine(templatesFolder, \"output.dicom\"), exportOptions); Step 3: Save as DICOM Path.Combine(templatesFolder, \"output.dicom\") constructs the output path (e.g., c:\\Users\\USER\\Downloads\\templates\\output.dicom). image.Save() converts and saves the loaded WebP image as a DICOM file using the DicomOptions. File.Delete(Path.Combine(templatesFolder, \"output.dicom\")); Step 4: Delete the Output File Deletes the newly created output.dicom file from the directory. This step suggests the code is for demonstration purposes (e.g., testing conversion) rather than permanent storage. } Closes the using block, disposing of the image object.",
                "https://products.aspose.com/imaging/net/conversion/webp-to-dicom/",
                ""
            ]
        ]
    },
    {
        "level": "5.",
        "title": "Typical Resolution & Image Dimensions",
        "content-type": "markdown",
        "content": " "
    },
    {
        "level": "5.1.",
        "title": "Spatial Resolution",
        "content-type": "markdown",
        "content": "512 \u00d7 512 pixels / Reference: https://pmc.ncbi.nlm.nih.gov/articles/PMC4209425/"
    },
    {
        "level": "5.2.",
        "title": "Voxel Size / Pixel Spacing",
        "content-type": "markdown",
        "content": "Pixel spacing ~0.1\u20130.3 mm, depending on system settings / Reference: Pixel spacing ~0.1\u20130.3 mm, depending on system settings"
    },
    {
        "level": "5.3.",
        "title": "Temporal Resolution (if applicable)",
        "content-type": "markdown",
        "content": "not applicable"
    },
    {
        "level": "6.",
        "title": "Data Size (Storage Requirements)",
        "content-type": "markdown",
        "content": ""
    },
    {
        "level": "6.1.",
        "title": "Single Image Size",
        "content-type": "markdown",
        "content": " 1\u20135 MB per OPG image, depending on resolution and compression / Reference: https://pubmed.ncbi.nlm.nih.gov/10717198/"
    },
    {
        "level": "6.2.",
        "title": "Typical Study Size",
        "content-type": "markdown",
        "content": "0\u201350 MB for a full dental OPG study (multiple views or patients) / Reference: https://pubmed.ncbi.nlm.nih.gov/10717198/"
    },
    {
        "level": "7.",
        "title": "Acquisition Device & Hardware Requirements",
        "content-type": "markdown",
        "content": " "
    },
    {
        "level": "7.1.",
        "title": "Equipment Used",
        "content-type": "markdown",
        "content": "Panoramic X-ray machine (e.g., Carestream CS 8100) / Reference: https://www.sciencedirect.com/science/article/abs/pii/S1120179724001339"
    },
    {
        "level": "7.2.",
        "title": "Typical Manufacturers",
        "content-type": "markdown",
        "content": "Carestream, Canon, Siemens, Gendex / Reference: https://pmc.ncbi.nlm.nih.gov/articles/PMC7461739/ , https://www.sciencedirect.com/science/article/abs/pii/S1120179724001339"
    },
    {
        "level": "8.",
        "title": "Common Clinical Applications",
        "content-type": "markdown",
        "content": " "
    },
    {
        "level": "8.1.",
        "title": "Primary Uses",
        "content-type": "markdown",
        "content": "Detection of dental caries, jaw fractures, and tooth impaction / Reference: https://pmc.ncbi.nlm.nih.gov/articles/PMC4209425/"
    },
    {
        "level": "8.2.",
        "title": "Specialized Uses",
        "content-type": "markdown",
        "content": "Orthodontic treatment planning, evaluation of mandibular lesions / Reference: https://pmc.ncbi.nlm.nih.gov/articles/PMC4209425/"
    },
    {
        "level": "9.",
        "title": " Radiation & Safety Considerations",
        "content-type": "markdown",
        "content": ""
    },
    {
        "level": "9.1.",
        "title": "Ionizing Radiation",
        "content-type": "markdown",
        "content": "Yes / Reference: https://www.iaea.org/resources/rpop/health-professionals/dentistry/radiation-doses"
    },
    {
        "level": "9.2.",
        "title": "Radiation Dose (if applicable)",
        "content-type": "markdown",
        "content": "~0.01\u20130.03 mGy (entrance surface dose) / Reference: https://www.iaea.org/resources/rpop/health-professionals/dentistry/radiation-doses"
    },
    {
        "level": "9.3.",
        "title": "Safety Concerns",
        "content-type": "markdown",
        "content": ""
    },
    {
        "level": "10.",
        "title": "",
        "content-type": "markdown",
        "content": ""
    },
    {
        "level": "10.1.",
        "title": "Common Preprocessing Steps",
        "content-type": "markdown",
        "content": "Image enhancement, alignment correction, noise reduction / Refernce: https://pmc.ncbi.nlm.nih.gov/articles/PMC7250122/"
    },
    {
        "level": "10.2.",
        "title": "Compression Methods (if any)",
        "content-type": "markdown",
        "content": "Lossless compression (e.g., DICOM standard) / Reference: https://pmc.ncbi.nlm.nih.gov/articles/PMC4247836/"
    },
    {
        "level": "11.",
        "title": "Challenges & Limitations",
        "content-type": "markdown",
        "content": ""
    },
    {
        "level": "11.1.",
        "title": "Technical Challenges",
        "content-type": "markdown",
        "content": "Motion artifacts, beam alignment issues / Reference: https://www.sciencedirect.com/science/article/abs/pii/S1120179724001339"
    },
    {
        "level": "11.2.",
        "title": "Clinical Limitations",
        "content-type": "markdown",
        "content": "Limited detail for small structures, overlap of anatomical features / Reference: https://pmc.ncbi.nlm.nih.gov/articles/PMC4209425/"
    },
    {
        "level": "prepration-meta-data-prepared_by",
        "title": "prepared_by",
        "content-type": "rawtext",
        "content": "Arman Gharehbahi"
    },
    {
        "level": "prepration-meta-data-confirmed_by",
        "title": "confirmed_by",
        "content-type": "rawtext",
        "content": ""
    },
    {
        "level": "prepration-meta-data-date_of_preparation",
        "title": "date_of_preparation",
        "content-type": "rawtext",
        "content": "2025-03-19"
    },
    {
        "level": "prepration-meta-data-planned_next_review",
        "title": "planned_next_review",
        "content-type": "rawtext",
        "content": ""
    },
    {
        "level": "prepration-meta-data-requires_completion",
        "title": "requires_completion",
        "content-type": "rawtext",
        "content": ""
    }
]