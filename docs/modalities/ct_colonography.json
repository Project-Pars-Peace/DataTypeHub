[
    {
        "level": "meta-data-id",
        "title": "id",
        "content-type": "rawtext",
        "content": "ct_colonography"
    },
    {
        "level": "meta-data-parents",
        "title": "parents",
        "content-type": "list_of_strings",
        "content": [
            "CT"
        ]
    },
    {
        "level": "meta-data-title",
        "title": "title",
        "content-type": "rawtext",
        "content": "CT Colonography (Virtual Colonoscopy)"
    },
    {
        "level": "meta-data-acronyms",
        "title": "acronyms",
        "content-type": "list_of_strings",
        "content": [
            "CTC https://radiopaedia.org/articles/ct-colonography-protocol",
            "",
            "",
            ""
        ]
    },
    {
        "level": "meta-data-shortDescription",
        "title": "shortDescription",
        "content-type": "rawtext",
        "content": "CT Colonography (CTC), also known as virtual colonoscopy, combines X-ray computed tomography (CT) with advanced 3D reconstruction software to visualize the colon\u2019s interior noninvasively.\n"
    },
    {
        "level": "",
        "title": "",
        "content-type": "table",
        "content": [
            [
                "conversion_from",
                "conversion_to",
                "Methodology",
                "Tools and Libraries Used",
                " How the Code Works",
                "Reference(s)"
            ],
            [
                "NIfTI: .nii",
                "DICOM (.dcm)",
                "\"This script provides a command-line interface (CLI) for converting NIfTI (Neuroimaging Informatics Technology Initiative) files into DICOM (Digital Imaging and Communications in Medicine) format using the nii2dcm library. It follows these key steps:  Parses command-line arguments for input NIfTI files, output directories, and optional parameters. Checks for the existence and validity of input/output files. Optionally allows specifying a reference DICOM file to transfer attributes. Calls the run_nii2dcm function to perform the actual conversion. Exits with an appropriate message if any errors occur. The script ensures flexibility by allowing different DICOM types and reference DICOM files, making it useful for medical imaging workflows.\"",
                "\"The script utilizes the following Python standard libraries and external modules:  Standard Libraries sys \u2013 Handles command-line arguments and exits the program when errors occur. argparse \u2013 Provides an easy way to parse and handle command-line arguments. pathlib \u2013 Manages file paths and ensures correct file and directory handling. External Modules nii2dcm.run \u2013 Contains the run_nii2dcm function that performs the actual NIfTI-to-DICOM conversion. nii2dcm._version \u2013 Stores the version of the nii2dcm package. These tools allow the script to provide an easy-to-use CLI utility for medical image conversion. \"",
                "\"1. Define the cli function python Copy Edit def cli(args=None): Defines the function cli, which serves as the entry point for the command-line execution. If no arguments are provided (args=None), it defaults to using command-line arguments (sys.argv[1:]). 2. Create an Argument Parser python Copy Edit parser = argparse.ArgumentParser(     prog=\"\"nii2dcm\"\",     description=\"\"nii2dcm - NIfTI file to DICOM conversion\"\" ) Uses argparse.ArgumentParser to define a CLI program named \"\"nii2dcm\"\", with a brief description of its function. 3. Define Command-Line Arguments python Copy Edit parser.add_argument(\"\"input_file\"\", type=str, help=\"\"[.nii/.nii.gz] input NIfTI file\"\") parser.add_argument(\"\"output_dir\"\", type=str, help=\"\"[directory] output DICOM path\"\") parser.add_argument(\"\"-d\"\", \"\"--dicom_type\"\", type=str, help=\"\"[string] type of DICOM. Available types: MR, SVR.\"\") parser.add_argument(\"\"-r\"\", \"\"--ref_dicom\"\", type=str, help=\"\"[.dcm] Reference DICOM file for Attribute transfer\"\") parser.add_argument(\"\"-v\"\", \"\"--version\"\", action=\"\"version\"\", version=__version__) input_file: Required argument specifying the input NIfTI file (.nii or .nii.gz). output_dir: Required argument specifying the output directory for DICOM files. -d / --dicom_type: (Optional) Specifies the type of DICOM output (e.g., MR, SVR). -r / --ref_dicom: (Optional) Specifies a reference DICOM file to transfer attributes. -v / --version: Displays the current version of the software. 4. Parse Arguments python Copy Edit args = parser.parse_args() Parses the command-line arguments and stores them in args. 5. Convert Input Paths to Path Objects python Copy Edit input_file = Path(args.input_file)   output_dir = Path(args.output_dir)   Converts the input and output paths into Path objects for easier file operations. 6. Validate Input and Output Paths python Copy Edit if not input_file.exists():     print(f\"\"Input file '{input_file}' not found\"\")     raise SystemExit(1)  if not output_dir.exists():     print(f\"\"Output directory '{output_dir}' does not exist\"\")     raise SystemExit(1) Checks if the input file exists; if not, it prints an error message and exits. Checks if the output directory exists; if not, it prints an error message and exits. 7. Handle Optional Arguments python Copy Edit if args.dicom_type is not None:     dicom_type = args.dicom_type  # TODO: add check that supplied dicom_type is permitted else:     dicom_type = None If a DICOM type is provided, it stores the value; otherwise, it sets dicom_type = None. python Copy Edit if args.ref_dicom is not None:     ref_dicom_file = Path(args.ref_dicom)   # TODO: add check that file is DICOM else:     ref_dicom_file = None If a reference DICOM file is provided, it converts it to a Path object; otherwise, it sets ref_dicom_file = None. 8. Execute the Conversion python Copy Edit run_nii2dcm(     input_file,     output_dir,     dicom_type,     ref_dicom_file ) Calls the run_nii2dcm function with the provided arguments to perform the actual NIfTI-to-DICOM conversion. 9. Define the Script Entry Point python Copy Edit if __name__ == \"\"__main__\"\":     sys.exit(cli()) Ensures the script runs the cli() function only if executed directly, not if imported as a module. Uses sys.exit(cli()) to ensure a clean exit after execution.\"",
                "https://github.com/tomaroberts/nii2dcm/blob/main/nii2dcm/__main__.py"
            ],
            [
                "2. .img/.hdr - Analyze 7.5",
                "DICOM (.dcm)",
                "\"First, you should convert .hdr format into .jpeg  , then you can convert .jpeg format into DICOM  .hdr 2 .jpeg This code is designed to convert .hdr files (hyperspectral image format) into .jpg format for easier visualization. The methodology follows these key steps:  Directory Scanning: The script iterates through the files in the specified folder ('a/') to locate .hdr files.  Image Reading: Using the spectral library, each .hdr file is read and stored as a hyperspectral image object.  Image Conversion: The save_rgb() function is employed to save the hyperspectral image as a .jpg file, using specific band indices ([29, 19, 9]) to map the RGB channels.  Output Generation: The generated .jpg files are saved in the same directory as the executing script. jpeg 2 dicom The code follows these steps:  Load an Image: The script loads an image file (e.g., PNG, BMP) using the Pillow library.  Convert Image Formats: If the image is in PNG or BMP format, it is converted to RGB format to ensure compatibility.  Convert Image Modes: The image is processed based on its pixel mode (e.g., grayscale, RGB, RGBA) and converted into a NumPy array.  Create DICOM Metadata: A DICOM dataset is created from scratch, and metadata (e.g., patient name, image dimensions, pixel data) is added to the dataset.  Save as DICOM: The final DICOM file is saved with a unique filename.  \"",
                "\".hdr 2 .jpeg fnmatch: For matching filename patterns (specifically .hdr files).  os: For directory navigation and file path handling.  spectral: For reading .hdr files and converting hyperspectral images to RGB.  spectral.io.envi: A submodule for handling ENVI-format hyperspectral data.  .jpeg to dicom: The following Python libraries are used in this script:  pydicom:  A library for working with DICOM files.  Used to create and manipulate DICOM datasets and metadata.  Key functionalities: Creating DICOM files, setting metadata, and saving files.  Pillow (PIL):  A Python Imaging Library used for opening, manipulating, and saving image files.  Used to load the input image, convert formats, and extract pixel data.  numpy:  A library for numerical computing in Python.  Used to convert image pixel data into a NumPy array for processing.  uuid:  A library for generating unique identifiers.  Used to create a unique filename for the output DICOM file. \"",
                "\".hdr 2 .jpeg import fnmatch import os from spectral import * import spectral.io.envi as envi  #spectral images will be the library to convert .hdr to .jpg #a/ is the directory of the hdr file is and saves the .jpg file in the location of the code  for file in os.listdir('a/'):         if fnmatch.fnmatch('a/'+ file, '*.hdr'):             print ('a/'+file)             img = open_image('a/'+file)             save_rgb(file+'.jpg', img, [29, 19, 9]) Import Libraries: Imports fnmatch, os, and spectral for file handling and hyperspectral image processing.  Iterate Through Directory: The os.listdir() function retrieves all files in the 'a/' folder.  File Matching: The fnmatch.fnmatch() function identifies files that end with .hdr.  Image Reading: For each matched file, open_image() reads the .hdr file into a hyperspectral image object.  Image Conversion: The save_rgb() function maps the hyperspectral data to RGB using specified bands and saves the output in .jpg format.  Output Path: The converted .jpg file is saved in the same folder where the script is executed.  .jpeg 2 dicom Here\u2019s a step-by-step breakdown of the code:  Step 1: Load the Input Image python Copy img = Image.open(INPUT_FILE) width, height = img.size print(\"\"File format is {} and size: {}, {}\"\".format(img.format, width, height)) The input image is loaded using Pillow's Image.open() method.  The image format (e.g., PNG, BMP) and dimensions (width, height) are printed.  Step 2: Convert Image Formats python Copy if img.format == 'PNG' or img.format == 'BMP':     img = img.convert('RGB') If the image is in PNG or BMP format, it is converted to RGB format using img.convert('RGB').  Step 3: Convert Image Modes python Copy if img.mode == 'L':     np_frame = numpy.array(img.getdata(), dtype=numpy.uint8)     np_frame = np_frame.reshape((height, width))     ds.PixelData = np_frame.tobytes() elif img.mode == 'RGBA' or img.mode == 'RGB':     np_frame = numpy.array(img.getdata(), dtype=numpy.uint8)     np_frame = np_frame.reshape((height, width, -1)) else:     print(\"\"Unknown image mode\"\")     return The image mode (e.g., grayscale, RGB, RGBA) is checked.  For grayscale (L mode), the image is converted to a 2D NumPy array.  For RGB or RGBA modes, the image is converted to a 3D NumPy array.  The pixel data is reshaped to match the image dimensions.  Step 4: Create DICOM Metadata python Copy ds = Dataset() ds.file_meta = Dataset() ds.file_meta.TransferSyntaxUID = pydicom.uid.ExplicitVRLittleEndian ds.file_meta.MediaStorageSOPClassUID = '1.2.840.10008.5.1.4.1.1.1.1' ds.file_meta.MediaStorageSOPInstanceUID = \"\"1.2.3\"\" ds.file_meta.ImplementationClassUID = \"\"1.2.3.4\"\"  ds.PatientName = 'Created'  ds.Rows = img.height ds.Columns = img.width ds.PhotometricInterpretation = \"\"YBR_FULL_422\"\" if np_frame.shape[1] == 3:     ds.SamplesPerPixel = 3 else:     ds.SamplesPerPixel = 1 ds.BitsStored = 8 ds.BitsAllocated = 8 ds.HighBit = 7 ds.PixelRepresentation = 0 ds.PlanarConfiguration = 0 ds.NumberOfFrames = 1  ds.SOPClassUID = generate_uid() ds.SOPInstanceUID = generate_uid() ds.StudyInstanceUID = generate_uid() ds.SeriesInstanceUID = generate_uid()  ds.PixelData = np_frame A new DICOM dataset (ds) is created using pydicom.  Metadata is added to the dataset, including:  Transfer syntax, SOP class, and instance UIDs.  Patient name (set to 'Created').  Image dimensions (rows and columns).  Photometric interpretation (e.g., YBR_FULL_422 for color images).  Pixel data properties (e.g., bits stored, bits allocated).  Unique identifiers (UIDs) are generated for the SOP class, instance, study, and series.  Step 5: Save as DICOM python Copy ds.is_little_endian = True ds.is_implicit_VR = False  ds.save_as(dicomized_filename, write_like_original=False) The dataset is configured to use little-endian byte order and explicit VR (Value Representation).  The DICOM file is saved with a unique filename generated using uuid.uuid4()\"",
                "https://github.com/jwitos/JPG-to-DICOM/blob/master/jpeg-to-dicom.py"
            ],
            [
                "MINC",
                "DICOM (.dcm)",
                "\"This code is a Perl script that converts MINC (Medical Imaging NetCDF) format files to DICOM (Digital Imaging and Communications in Medicine) format. The script reads a MINC file, extracts relevant information, and creates a series of DICOM files, one for each slice of the 3D volume. It follows these main steps:  Parse command-line arguments  Reshape the input MINC file  Create DICOM data structure and populate it with metadata  Iterate through slices, creating a DICOM file for each  Write DICOM files to the specified output directory  \"",
                "\"Perl programming language  Perl modules:  Getopt::Long (for parsing command-line options)  Pod::Usage (for generating help/usage information)  File::Basename (for file path manipulation)  File::Temp (for creating temporary directories)  Time::HiRes (for high-resolution time functions)  Cwd (for working with current directory)  DICOM (for DICOM file manipulation)  External tools:  mincreshape (for reshaping MINC files)  mincinfo (for extracting MINC file information)  mincextract (for extracting slice data from MINC files)\"",
                "\"a. Parse command-line arguments and set up options b. Check for input file existence and create output directory if needed c. Reshape input MINC file to standardized orientation (zyx) d. Create DICOM object and populate metadata:  File metadata (group 0x0002)  Patient information (group 0x0010)  Study and series information (groups 0x0008, 0x0020)  Image-specific metadata (groups 0x0018, 0x0028) e. Extract image dimensions and other properties from MINC file f. Iterate through each slice of the MINC volume:  Update slice-specific metadata (e.g., SOPInstanceUID, ImagePositionPatient)  Extract slice data using mincextract  Set pixel data in DICOM object  Write DICOM file for the current slice g. Provide utility functions for hashing and size calculation  The script uses a combination of MINC tools and DICOM libraries to perform the conversion, ensuring that relevant metadata is transferred and the resulting DICOM files conform to the standard as much as possible.  Related What are the key methodologies used in this code Which tools and libraries are essential for this code Can you break down the step-by-step execution of this code \"",
                "https://github.com/andrewjanke/mnc2dcm/blob/master/mnc2dcm"
            ],
            [
                "TIFF: .tif",
                "DICOM (.dcm)",
                "\"The code follows these steps:  Load Image Formats: The script identifies supported input and output image formats.  Process Conversion: For each input format, the script attempts to convert it into all supported output formats.  Save Output: The converted files are saved, and temporary files are deleted if specified.  Handle Vector and Raster Images: The script distinguishes between vector and raster images and applies appropriate conversion options.  \"",
                "\"The following tools and libraries are used in this script:  Aspose.Imaging:  A powerful library for image processing and conversion.  Supports a wide range of formats, including TIFF, PNG, BMP, JPEG, DICOM, and more.  Used for loading, converting, and saving images.  os:  A Python standard library for interacting with the operating system.  Used for file path manipulation and checking file existence.  Environment Variables:  The script uses environment variables (TEMPLATE_DIR and SAVE_OUTPUT) to configure the input/output directories and whether to delete output files.  \"",
                "\"Here\u2019s a step-by-step breakdown of the code:  Step 1: Set Up Directories python Copy if 'TEMPLATE_DIR' in os.environ:     templates_folder = os.environ['TEMPLATE_DIR'] else:     templates_folder = r\"\"C:\\Users\\USER\\Downloads\\templates\"\"  delete_output = 'SAVE_OUTPUT' not in os.environ The script checks if the TEMPLATE_DIR environment variable is set. If not, it defaults to a local directory (C:\\Users\\USER\\Downloads\\templates).  The delete_output flag determines whether to delete the output files after conversion (based on the SAVE_OUTPUT environment variable).  Step 2: Define Conversion Function python Copy def process_convertion():     import_formats, export_formats = get_available_image_formats()          for import_key, import_value in import_formats.items():         format_ext = import_key         input_file = os.path.join(templates_folder, f\"\"template.{format_ext}\"\")                  if not os.path.exists(input_file):             continue                  for export_key, export_value in export_formats.items():             output_file = os.path.join(templates_folder, f\"\"convert-{format_ext}-to-{export_key}.{export_key}\"\")             print(\"\"Processing conversion:\"\" + output_file)             with Image.load(input_file) as image:                 export_options = export_value.clone()                 if is_assignable(image, VectorImage):                     rasterization_options = import_value                     rasterization_options.page_width = float(image.width)                     rasterization_options.page_height = float(image.height)                     export_options.vector_rasterization_options = rasterization_options                  image.save(output_file, export_options)              if delete_output:                 os.remove(output_file) The process_convertion() function performs the actual conversion.  It retrieves the available input and output formats using get_available_image_formats().  For each input format, it checks if a corresponding template file exists (e.g., template.tiff).  For each output format, it creates an output file (e.g., convert-tiff-to-dicom.dicom).  The image is loaded using Image.load(), and conversion options are applied.  If the image is a vector image, rasterization options are configured.  The converted image is saved, and the output file is deleted if delete_output is True.  Step 3: Define Supported Formats python Copy def get_available_image_formats():     obj_init = Jpeg2000Options()     obj_init.codec = Jpeg2000Codec.J2K     obj_init2 = Jpeg2000Options()     obj_init2.codec = Jpeg2000Codec.JP2     obj_init3 = PngOptions()     obj_init3.color_type = PngColorType.TRUECOLOR_WITH_ALPHA     obj_init4 = {}     obj_init4[\"\"bmp\"\"] = BmpOptions()     obj_init4[\"\"gif\"\"] = GifOptions()     obj_init4[\"\"dicom\"\"] = DicomOptions()     obj_init4[\"\"jpg\"\"] = JpegOptions()     obj_init4[\"\"jpeg\"\"] = JpegOptions()     obj_init4[\"\"jpeg2000\"\"] = Jpeg2000Options()     obj_init4[\"\"j2k\"\"] = obj_init     obj_init4[\"\"jp2\"\"] = obj_init2     obj_init4[\"\"png\"\"] = obj_init3     obj_init4[\"\"apng\"\"] = ApngOptions()     obj_init4[\"\"tiff\"\"] = TiffOptions(TiffExpectedFormat.DEFAULT)     obj_init4[\"\"tif\"\"] = TiffOptions(TiffExpectedFormat.DEFAULT)     obj_init4[\"\"tga\"\"] = TgaOptions()     obj_init4[\"\"webp\"\"] = WebPOptions()     obj_init4[\"\"ico\"\"] = IcoOptions(FileFormat.PNG, 24)     raster_formats_that_support_export_and_import = obj_init4          obj_init5 = EmfOptions()     obj_init5.compress = True     obj_init6 = WmfOptions()     obj_init6.compress = True     obj_init7 = SvgOptions()     obj_init7.compress = True     obj_init8 = {}     obj_init8[\"\"emf\"\"] = (EmfOptions(), EmfRasterizationOptions())     obj_init8[\"\"svg\"\"] = (SvgOptions(), SvgRasterizationOptions())     obj_init8[\"\"wmf\"\"] = (WmfOptions(), WmfRasterizationOptions())     obj_init8[\"\"emz\"\"] = (obj_init5, EmfRasterizationOptions())     obj_init8[\"\"wmz\"\"] = (obj_init6, WmfRasterizationOptions())     obj_init8[\"\"svgz\"\"] = (obj_init7, SvgRasterizationOptions())     vector_formats_that_support_export_and_import = obj_init8          obj_init9 = DxfOptions()     obj_init9.text_as_lines = True     obj_init9.convert_text_beziers = True     obj_init10 = {}     obj_init10[\"\"psd\"\"] = PsdOptions()     obj_init10[\"\"dxf\"\"] = obj_init9     obj_init10[\"\"pdf\"\"] = PdfOptions()     obj_init10[\"\"html\"\"] = Html5CanvasOptions()     formats_only_for_export = obj_init10          obj_init11 = {}     obj_init11[\"\"djvu\"\"] = None     obj_init11[\"\"dng\"\"] = None     obj_init11[\"\"dib\"\"] = None     formats_only_for_import = obj_init11          obj_init12 = {}     obj_init12[\"\"eps\"\"] = EpsRasterizationOptions()     obj_init12[\"\"cdr\"\"] = CdrRasterizationOptions()     obj_init12[\"\"cmx\"\"] = CmxRasterizationOptions()     obj_init12[\"\"otg\"\"] = OtgRasterizationOptions()     obj_init12[\"\"odg\"\"] = OdgRasterizationOptions()     vector_formats_only_for_import = obj_init12          # Get total set of formats to what we can export images     export_formats = {k: v[0] for k, v in vector_formats_that_support_export_and_import.items()}     export_formats.update(formats_only_for_export)     export_formats.update(raster_formats_that_support_export_and_import)          # Get total set of formats that can be loaded     import_formats = {k : VectorRasterizationOptions() for k in formats_only_for_import}     import_formats.update(vector_formats_only_for_import)     import_formats.update({k : v[1] for k, v in vector_formats_that_support_export_and_import.items()})          return import_formats, export_formats The get_available_image_formats() function defines the supported input and output formats.  It categorizes formats into raster, vector, and special formats (e.g., PDF, HTML).  It returns two dictionaries: import_formats (formats that can be loaded) and export_formats (formats that can be saved).  Step 4: Run the Conversion python Copy # run process_convertion() The script executes the process_convertion() function to perform the conversions.\"",
                "https://products.aspose.com/imaging/python-net/conversion/tiff-to-dicom/"
            ],
            [
                "JPEG: .jpg",
                "DICOM (.dcm)",
                "\"The code follows these steps:  Load an Image: The script loads an image file (e.g., PNG, BMP) using the Pillow library.  Convert Image Formats: If the image is in PNG or BMP format, it is converted to RGB format to ensure compatibility.  Convert Image Modes: The image is processed based on its pixel mode (e.g., grayscale, RGB, RGBA) and converted into a NumPy array.  Create DICOM Metadata: A DICOM dataset is created from scratch, and metadata (e.g., patient name, image dimensions, pixel data) is added to the dataset.  Save as DICOM: The final DICOM file is saved with a unique filename.  \"",
                "\"The following Python libraries are used in this script:  pydicom:  A library for working with DICOM files.  Used to create and manipulate DICOM datasets and metadata.  Key functionalities: Creating DICOM files, setting metadata, and saving files.  Pillow (PIL):  A Python Imaging Library used for opening, manipulating, and saving image files.  Used to load the input image, convert formats, and extract pixel data.  numpy:  A library for numerical computing in Python.  Used to convert image pixel data into a NumPy array for processing.  uuid:  A library for generating unique identifiers.  Used to create a unique filename for the output DICOM file.\"",
                "\"Here\u2019s a step-by-step breakdown of the code:  Step 1: Load the Input Image python Copy img = Image.open(INPUT_FILE) width, height = img.size print(\"\"File format is {} and size: {}, {}\"\".format(img.format, width, height)) The input image is loaded using Pillow's Image.open() method.  The image format (e.g., PNG, BMP) and dimensions (width, height) are printed.  Step 2: Convert Image Formats python Copy if img.format == 'PNG' or img.format == 'BMP':     img = img.convert('RGB') If the image is in PNG or BMP format, it is converted to RGB format using img.convert('RGB').  Step 3: Convert Image Modes python Copy if img.mode == 'L':     np_frame = numpy.array(img.getdata(), dtype=numpy.uint8)     np_frame = np_frame.reshape((height, width))     ds.PixelData = np_frame.tobytes() elif img.mode == 'RGBA' or img.mode == 'RGB':     np_frame = numpy.array(img.getdata(), dtype=numpy.uint8)     np_frame = np_frame.reshape((height, width, -1)) else:     print(\"\"Unknown image mode\"\")     return The image mode (e.g., grayscale, RGB, RGBA) is checked.  For grayscale (L mode), the image is converted to a 2D NumPy array.  For RGB or RGBA modes, the image is converted to a 3D NumPy array.  The pixel data is reshaped to match the image dimensions.  Step 4: Create DICOM Metadata python Copy ds = Dataset() ds.file_meta = Dataset() ds.file_meta.TransferSyntaxUID = pydicom.uid.ExplicitVRLittleEndian ds.file_meta.MediaStorageSOPClassUID = '1.2.840.10008.5.1.4.1.1.1.1' ds.file_meta.MediaStorageSOPInstanceUID = \"\"1.2.3\"\" ds.file_meta.ImplementationClassUID = \"\"1.2.3.4\"\"  ds.PatientName = 'Created'  ds.Rows = img.height ds.Columns = img.width ds.PhotometricInterpretation = \"\"YBR_FULL_422\"\" if np_frame.shape[1] == 3:     ds.SamplesPerPixel = 3 else:     ds.SamplesPerPixel = 1 ds.BitsStored = 8 ds.BitsAllocated = 8 ds.HighBit = 7 ds.PixelRepresentation = 0 ds.PlanarConfiguration = 0 ds.NumberOfFrames = 1  ds.SOPClassUID = generate_uid() ds.SOPInstanceUID = generate_uid() ds.StudyInstanceUID = generate_uid() ds.SeriesInstanceUID = generate_uid()  ds.PixelData = np_frame A new DICOM dataset (ds) is created using pydicom.  Metadata is added to the dataset, including:  Transfer syntax, SOP class, and instance UIDs.  Patient name (set to 'Created').  Image dimensions (rows and columns).  Photometric interpretation (e.g., YBR_FULL_422 for color images).  Pixel data properties (e.g., bits stored, bits allocated).  Unique identifiers (UIDs) are generated for the SOP class, instance, study, and series.  Step 5: Save as DICOM python Copy ds.is_little_endian = True ds.is_implicit_VR = False  ds.save_as(dicomized_filename, write_like_original=False) The dataset is configured to use little-endian byte order and explicit VR (Value Representation).  The DICOM file is saved with a unique filename generated using uuid.uuid4()\"",
                "https://github.com/jwitos/JPG-to-DICOM/blob/master/jpeg-to-dicom.py"
            ],
            [
                "PNG: .png",
                "DICOM (.dcm)",
                "Similar to JPEG format (written in row above)",
                "\"The following Python libraries are used in this script:  pydicom:  A library for working with DICOM files.  Used to create and manipulate DICOM datasets and metadata.  Key functionalities: Creating DICOM files, setting metadata, and saving files.  Pillow (PIL):  A Python Imaging Library used for opening, manipulating, and saving image files.  Used to load the input image, convert formats, and extract pixel data.  numpy:  A library for numerical computing in Python.  Used to convert image pixel data into a NumPy array for processing.  uuid:  A library for generating unique identifiers.  Used to create a unique filename for the output DICOM file.\"",
                "\"Here\u2019s a step-by-step breakdown of the code:  Step 1: Load the Input Image python Copy img = Image.open(INPUT_FILE) width, height = img.size print(\"\"File format is {} and size: {}, {}\"\".format(img.format, width, height)) The input image is loaded using Pillow's Image.open() method.  The image format (e.g., PNG, BMP) and dimensions (width, height) are printed.  Step 2: Convert Image Formats python Copy if img.format == 'PNG' or img.format == 'BMP':     img = img.convert('RGB') If the image is in PNG or BMP format, it is converted to RGB format using img.convert('RGB').  Step 3: Convert Image Modes python Copy if img.mode == 'L':     np_frame = numpy.array(img.getdata(), dtype=numpy.uint8)     np_frame = np_frame.reshape((height, width))     ds.PixelData = np_frame.tobytes() elif img.mode == 'RGBA' or img.mode == 'RGB':     np_frame = numpy.array(img.getdata(), dtype=numpy.uint8)     np_frame = np_frame.reshape((height, width, -1)) else:     print(\"\"Unknown image mode\"\")     return The image mode (e.g., grayscale, RGB, RGBA) is checked.  For grayscale (L mode), the image is converted to a 2D NumPy array.  For RGB or RGBA modes, the image is converted to a 3D NumPy array.  The pixel data is reshaped to match the image dimensions.  Step 4: Create DICOM Metadata python Copy ds = Dataset() ds.file_meta = Dataset() ds.file_meta.TransferSyntaxUID = pydicom.uid.ExplicitVRLittleEndian ds.file_meta.MediaStorageSOPClassUID = '1.2.840.10008.5.1.4.1.1.1.1' ds.file_meta.MediaStorageSOPInstanceUID = \"\"1.2.3\"\" ds.file_meta.ImplementationClassUID = \"\"1.2.3.4\"\"  ds.PatientName = 'Created'  ds.Rows = img.height ds.Columns = img.width ds.PhotometricInterpretation = \"\"YBR_FULL_422\"\" if np_frame.shape[1] == 3:     ds.SamplesPerPixel = 3 else:     ds.SamplesPerPixel = 1 ds.BitsStored = 8 ds.BitsAllocated = 8 ds.HighBit = 7 ds.PixelRepresentation = 0 ds.PlanarConfiguration = 0 ds.NumberOfFrames = 1  ds.SOPClassUID = generate_uid() ds.SOPInstanceUID = generate_uid() ds.StudyInstanceUID = generate_uid() ds.SeriesInstanceUID = generate_uid()  ds.PixelData = np_frame A new DICOM dataset (ds) is created using pydicom.  Metadata is added to the dataset, including:  Transfer syntax, SOP class, and instance UIDs.  Patient name (set to 'Created').  Image dimensions (rows and columns).  Photometric interpretation (e.g., YBR_FULL_422 for color images).  Pixel data properties (e.g., bits stored, bits allocated).  Unique identifiers (UIDs) are generated for the SOP class, instance, study, and series.  Step 5: Save as DICOM python Copy ds.is_little_endian = True ds.is_implicit_VR = False  ds.save_as(dicomized_filename, write_like_original=False) The dataset is configured to use little-endian byte order and explicit VR (Value Representation).  The DICOM file is saved with a unique filename generated using uuid.uuid4()\"",
                "https://github.com/jwitos/JPG-to-DICOM/blob/master/jpeg-to-dicom.py"
            ],
            [
                "BMP: .bmp",
                "DICOM (.dcm)",
                "\"The code follows these steps:  Load the BMP Image: The script loads a BMP image file from a specified directory.  Set Up DICOM Options: It creates an instance of DicomOptions to configure the output DICOM file.  Save as DICOM: The BMP image is saved as a DICOM file.  Clean Up: The output DICOM file is deleted (optional, for demonstration purposes).\"",
                "\"The following tools and libraries are used in this code:  Aspose.Imaging:  A powerful .NET library for image processing and conversion.  Supports a wide range of formats, including BMP, DICOM, PNG, JPEG, and more.  Used for loading, converting, and saving images.  System.IO:  A .NET namespace for file and directory manipulation.  Used for handling file paths and deleting files.\"",
                "\"Here\u2019s a step-by-step breakdown of the code:  Step 1: Set Up the Templates Folder csharp Copy string templatesFolder = @\"\"c:\\Users\\USER\\Downloads\\templates\\\"\"; The templatesFolder variable specifies the directory where the input BMP file (template.bmp) is located.  You can download the image templates from this GitHub repository and update the path accordingly.  Step 2: Load the BMP Image csharp Copy using (var image = Aspose.Imaging.Image.Load(Path.Combine(templatesFolder, @\"\"template.bmp\"\"))) The Image.Load() method loads the BMP image (template.bmp) from the specified directory.  The using statement ensures that the image resources are properly disposed of after use.  Step 3: Set Up DICOM Options csharp Copy var exportOptions = new Aspose.Imaging.ImageOptions.DicomOptions(); An instance of DicomOptions is created to configure the output DICOM file.  This object allows you to customize DICOM-specific settings (e.g., compression, metadata).  Step 4: Save as DICOM csharp Copy image.Save(Path.Combine(templatesFolder, \"\"output.dicom\"\"), exportOptions); The image.Save() method saves the BMP image as a DICOM file (output.dicom) in the specified directory.  The exportOptions object is passed to configure the DICOM output.  Step 5: Clean Up csharp Copy File.Delete(Path.Combine(templatesFolder, \"\"output.dicom\"\")); The output DICOM file (output.dicom) is deleted after conversion.  This step is optional and can be removed if you want to keep the output file.  4. Key Points Input: The script expects a BMP file (template.bmp) in the specified directory.  Output: A DICOM file (output.dicom) is generated in the same directory.  Aspose.Imaging: The library handles the conversion process seamlessly.  Clean Up: The output file is deleted after conversion (optional).  5. Example Workflow Input: A BMP file (template.bmp).  Output: A DICOM file (output.dicom).  Use Case: This script can be used to convert BMP images into DICOM format for medical imaging applications.  6. Prerequisites Install the Aspose.Imaging library via NuGet:  bash Copy Install-Package Aspose.Imaging Download the image templates from this GitHub repository and update the templatesFolder path.\"",
                "https://products.aspose.com/imaging/net/conversion/bmp-to-dicom/"
            ],
            [
                "NRRD: .nrrd",
                "DICOM (.dcm)",
                "\"The methodology involves two main processes:  Conversion from NRRD to DICOM for TCIA:  Step 1: Convert NRRD images (ultrasound and MR) to DICOM images.  Ultrasound images are converted using Dicom3tools.  MR data is converted using 3D Slicer.  Step 2: Convert NRRD segmentation files (SEG) to DICOM SEG using dcmqi with DICOM images as a reference.  Conversion of TCIA Imaging Data from DICOM to NRRD:  Convert DICOM imaging data downloaded from TCIA into NIfTI or NRRD formats using Python scripts.\"",
                "\"The following tools and libraries are used in the process:  Dicom3tools: For converting ultrasound NRRD images to multi-frame DICOM files.  3D Slicer: For converting MR NRRD images to DICOM format.  dcmqi: For converting NRRD segmentation files to DICOM SEG.  Python: For scripting the conversion processes.  Required Python packages are listed in requirements.txt (not explicitly mentioned but implied).  Java: Required for running certain tools or scripts.  TCIA: The Cancer Imaging Archive, from which DICOM data is downloaded.\"",
                "\"Step 1: Import Libraries and Handle Dependencies Imports: The script begins by importing essential Python libraries: os and subprocess for file and system operations. slicer for interacting with 3D Slicer, a medical imaging software. argparse (misspelled as arsparse in the OCR) for command-line argument parsing. DiCOMScalarVolumePlugin (likely DICOMScalarVolumePlugin) for DICOM export functionality in Slicer. Dynamic Imports: The script attempts to import additional libraries (pandas, tqdm, natsort, pydicom). If they\u2019re not installed, it uses slicer.util.pip_install to install them within the 3D Slicer environment: pandas for data manipulation and saving results to CSV. tqdm for progress bars. natsort for natural sorting of file names. pydicom for reading and writing DICOM files. Other Imports: numpy (np) for numerical operations. Step 2: Command-Line Argument Parsing (parsing_data) Function: parsing_data() Purpose: Sets up an argparse.ArgumentParser to accept two optional command-line arguments: --path_nrrd: Path to the input NRRD dataset (default: ./nrrd). --path_dicom: Path to the output DICOM dataset (default: ./dicom_folder). Returns: Parsed options (opt) containing these paths. Step 3: Download PixelMed Tool (download_pixelmed) Function: download_pixelmed() Purpose: Downloads the pixelmed.jar file, a Java-based tool for NRRD-to-DICOM conversion, from a specified URL if it\u2019s not already present. Details: Uses urllib.request.urlopen to fetch the file from http://www.dclunie.com/.../pixelmed.jar. Saves it locally as pixelmed.jar. Step 4: Core NRRD-to-DICOM Conversion with PixelMed (convert_nrrd_to_dicom_pure) Function: convert_nrrd_to_dicom_pure() Purpose: Converts an NRRD file to DICOM using the PixelMed tool. Parameters: path_nrrd: Path to the input NRRD file. path_dicom: Path to the output DICOM file. Metadata like patient_name, patient_id, study_id, series_number, and instance_number. Steps: Checks if pixelmed.jar exists; if not, calls download_pixelmed(). Constructs a Java command using subprocess.call: java -cp pixelmed.jar -Djava.awt.headless=true com.pixelmed.convert.NRRDToDicom. Passes the input NRRD path, output DICOM path, and metadata as arguments. Executes the command to perform the conversion. Step 5: Add Metadata to DICOM Files (add_info_to_dicom) Function: add_info_to_dicom() Purpose: Modifies a DICOM file to add or update specific metadata tags. Parameters: path_dicom: Path to the DICOM file. Optional tags: study_instancees_uid (likely a typo for study_instance_uid), study_description, series_description, modality. Steps: Reads the DICOM file using pydicom.dcmread. Updates fields if provided (e.g., StudyInstanceUID, StudyDescription, SeriesDescription, Modality). Sets a hardcoded StudyDate (DATE = '19990101'). Writes the modified DICOM file back using pydicom.dcmwrite. Step 6: Conversion Using 3D Slicer (convert_dicom) Function: convert_dicom() Purpose: Converts an NRRD file to DICOM using 3D Slicer\u2019s built-in tools. Parameters: path_nrrd: Path to the NRRD file. path_output: Root DICOM output folder. series_number: Series number (e.g., 1 for pre-dura ultrasound). study_instanceid: Study instance UID. Steps: Metadata Extraction: Derives patient_id, study_id, and series_description from the NRRD file path. Sets study_instance_uid based on whether \"\"Preop\"\" is in the path (1.<patient_id> or 2.<patient_id>). Determines modality (MR or US) based on the file path. Adjusts series_number and series_description for ultrasound cases (pre_dura, post_dura, pre_imri). Load NRRD: Loads the NRRD file into Slicer using slicer.util.loadVolume. Subject Hierarchy: Creates a subject hierarchy in Slicer with patient, study, and volume nodes. Assigns the volume to the study. Export to DICOM: Uses DICOMScalarVolumePlugin to examine and export the volume. Sets output folder structure (e.g., <patient_id>-<patient_name>/<DATE>-<study_id>). Tags the DICOM file with metadata (PatientID, StudyID, Modality, etc.). Cleanup: Removes the volume node from Slicer\u2019s scene. Step 7: Conversion Using PixelMed (convert_dicom_clunie) Function: convert_dicom_clunie() Purpose: Alternative NRRD-to-DICOM conversion using PixelMed, with additional folder structuring. Parameters: Same as convert_dicom(). Steps: Metadata Extraction: Similar to convert_dicom(), extracts patient and study info from the NRRD path. Output Path: Constructs a nested folder structure: <patient_id>-<patient_name>/<DATE>-<study_id>/<series_number>-<series_description>. Conversion: Calls convert_nrrd_to_dicom_pure() to generate the DICOM file. Metadata Update: Calls add_info_to_dicom() to add additional tags. Step 8: Main Execution Loop (main) Function: main() Purpose: Orchestrates the conversion process for multiple cases. Steps: Parse Arguments: Calls parsing_data() to get input/output paths. List Cases: Uses natsorted to list directories in opt.path_nrrd. Process Each Case: Preoperative MRI: Folder: Preop-MR. Generates a unique study_instanceid_preop using random numbers. Converts each NRRD file with convert_dicom. Intraoperative US: Folder: Intraop-US. Generates a unique study_instanceid_intraop. Converts each NRRD file with convert_dicom_clunie. Intraoperative MR: Folder: Intraop-MR. Converts each NRRD file with convert_dicom, incrementing series_number. Track Results: Stores case IDs and study UIDs in a dictionary (df). Save Results: Writes df to corr.csv. Report Errors: Prints any errors logged during processing. Step 9: Entry Point Check: if __name__ == '_main_': (should be __main__, likely an OCR typo). Action: Calls main() to start the script. Key Features and Notes Dual Conversion Methods: Uses both 3D Slicer (convert_dicom) and PixelMed (convert_dicom_clunie) for flexibility. Metadata Handling: Dynamically assigns patient, study, and series metadata based on file paths. Error Handling: Logs errors in a global errors list for reporting. File Organization: Creates a structured DICOM folder hierarchy based on patient and study info. Dependencies: Relies on external tools (PixelMed) and Slicer\u2019s Python environment. \"",
                "https://github.com/ReubenDo/ReMIND"
            ],
            [
                "MetaImage: .mhd",
                "DICOM (.dcm)",
                "First, you should convert your .mhd image to NIfTI format (.nii) using the SimpleITK library. then you can convert the NIFTI .nii format to dicom format.",
                "\"SimpleITK (convert .mhd to nifti)   Converting NIFTI format to Dicom: The script utilizes the following Python standard libraries and external modules:  Standard Libraries sys \u2013 Handles command-line arguments and exits the program when errors occur. argparse \u2013 Provides an easy way to parse and handle command-line arguments. pathlib \u2013 Manages file paths and ensures correct file and directory handling. External Modules nii2dcm.run \u2013 Contains the run_nii2dcm function that performs the actual NIfTI-to-DICOM conversion. nii2dcm._version \u2013 Stores the version of the nii2dcm package. These tools allow the script to provide an easy-to-use CLI utility for medical image conversion. \"",
                "\"convert .mhd to nifti:   Import the SimpleITK library:  python import SimpleITK as sitk SimpleITK is a simplified layer built on top of the Insight Toolkit (ITK) for image analysis and processing.  Read the input image:  python img = sitk.ReadImage(\"\"input.mhd\"\") This line reads the MetaImage file named \"\"input.mhd\"\" and stores it in the img variable as a SimpleITK image object.  Write the image in NIfTI format:  python sitk.WriteImage(img, \"\"output.nii\"\") This line writes the image stored in img to a new file named \"\"output.nii\"\" in NIfTI format.  This code effectively converts a medical image from MetaImage (.mhd) format to NIfTI (.nii) format, which are both commonly used in medical imaging. The conversion preserves the image data and metadata, allowing for seamless use in different software tools that support these formats.  Converting NIFTI to DICOM:  1. Define the cli function python Copy Edit def cli(args=None): Defines the function cli, which serves as the entry point for the command-line execution. If no arguments are provided (args=None), it defaults to using command-line arguments (sys.argv[1:]). 2. Create an Argument Parser python Copy Edit parser = argparse.ArgumentParser(     prog=\"\"nii2dcm\"\",     description=\"\"nii2dcm - NIfTI file to DICOM conversion\"\" ) Uses argparse.ArgumentParser to define a CLI program named \"\"nii2dcm\"\", with a brief description of its function. 3. Define Command-Line Arguments python Copy Edit parser.add_argument(\"\"input_file\"\", type=str, help=\"\"[.nii/.nii.gz] input NIfTI file\"\") parser.add_argument(\"\"output_dir\"\", type=str, help=\"\"[directory] output DICOM path\"\") parser.add_argument(\"\"-d\"\", \"\"--dicom_type\"\", type=str, help=\"\"[string] type of DICOM. Available types: MR, SVR.\"\") parser.add_argument(\"\"-r\"\", \"\"--ref_dicom\"\", type=str, help=\"\"[.dcm] Reference DICOM file for Attribute transfer\"\") parser.add_argument(\"\"-v\"\", \"\"--version\"\", action=\"\"version\"\", version=__version__) input_file: Required argument specifying the input NIfTI file (.nii or .nii.gz). output_dir: Required argument specifying the output directory for DICOM files. -d / --dicom_type: (Optional) Specifies the type of DICOM output (e.g., MR, SVR). -r / --ref_dicom: (Optional) Specifies a reference DICOM file to transfer attributes. -v / --version: Displays the current version of the software. 4. Parse Arguments python Copy Edit args = parser.parse_args() Parses the command-line arguments and stores them in args. 5. Convert Input Paths to Path Objects python Copy Edit input_file = Path(args.input_file)   output_dir = Path(args.output_dir)   Converts the input and output paths into Path objects for easier file operations. 6. Validate Input and Output Paths python Copy Edit if not input_file.exists():     print(f\"\"Input file '{input_file}' not found\"\")     raise SystemExit(1)  if not output_dir.exists():     print(f\"\"Output directory '{output_dir}' does not exist\"\")     raise SystemExit(1) Checks if the input file exists; if not, it prints an error message and exits. Checks if the output directory exists; if not, it prints an error message and exits. 7. Handle Optional Arguments python Copy Edit if args.dicom_type is not None:     dicom_type = args.dicom_type  # TODO: add check that supplied dicom_type is permitted else:     dicom_type = None If a DICOM type is provided, it stores the value; otherwise, it sets dicom_type = None. python Copy Edit if args.ref_dicom is not None:     ref_dicom_file = Path(args.ref_dicom)   # TODO: add check that file is DICOM else:     ref_dicom_file = None If a reference DICOM file is provided, it converts it to a Path object; otherwise, it sets ref_dicom_file = None. 8. Execute the Conversion python Copy Edit run_nii2dcm(     input_file,     output_dir,     dicom_type,     ref_dicom_file ) Calls the run_nii2dcm function with the provided arguments to perform the actual NIfTI-to-DICOM conversion. 9. Define the Script Entry Point python Copy Edit if __name__ == \"\"__main__\"\":     sys.exit(cli()) Ensures the script runs the cli() function only if executed directly, not if imported as a module. Uses sys.exit(cli()) to ensure a clean exit after execution.\"",
                "https://github.com/tomaroberts/nii2dcm/blob/main/nii2dcm/__main__.py"
            ]
        ]
    },
    {
        "level": "4.",
        "title": "Data Type & File Format",
        "content-type": "markdown",
        "content": ""
    },
    {
        "level": "4.1.",
        "title": "Primary File Format(s)",
        "content-type": "markdown",
        "content": "DICOM (.dcm)\tNIfTI: .nii\tAnalyze: .img/.hdr\tMINC\tTIFF: .tif\tJPEG: .jpg\tPNG: .png\tBMP: .bmp\tNRRD: .nrrd\tMetaImage: .mhd/.raw   References = https://pmc.ncbi.nlm.nih.gov/articles/PMC3948928/"
    },
    {
        "level": "4.2.",
        "title": "Data Type",
        "content-type": "markdown",
        "content": "grayscale\t3D  References =  https://radiopaedia.org/articles/ct-colonography-protocol    https://ajronline.org/doi/10.2214/AJR.07.2136 "
    },
    {
        "level": "4.3.",
        "title": "Related Data Types (parent type)",
        "content-type": "markdown",
        "content": "CT  "
    },
    {
        "level": "4.4.",
        "title": "Standard Storage Format (which one in 4.1)",
        "content-type": "markdown",
        "content": "DICOM (.dcm)"
    },
    {
        "level": "5.",
        "title": "Typical Resolution & Image Dimensions",
        "content-type": "markdown",
        "content": ""
    },
    {
        "level": "5.1.",
        "title": "Spatial Resolution",
        "content-type": "markdown",
        "content": " 512x512 pixels to 1024x1024 pixels per slice. The actual physical size of each pixel depends on the field of view (FOV) and reconstruction parameters, but is generally between 0.5-1.0 mm  References = https://pmc.ncbi.nlm.nih.gov/articles/PMC5608195/ "
    },
    {
        "level": "5.2.",
        "title": "Voxel Size / Pixel Spacing ",
        "content-type": "markdown",
        "content": "typically ranges from 0.5 mm to 3 mm (isotropic), depending on various factors References = https://pmc.ncbi.nlm.nih.gov/articles/PMC6182748/"
    },
    {
        "level": "5.3.",
        "title": "Temporal Resolution (if applicable)",
        "content-type": "markdown",
        "content": "Typically ranges between 100 to 500 milliseconds per rotation, depending on the CT scanner model and technology (e.g., single-source vs. dual-source CT). (temporal resolution in CT imaging is related to speed, it's more about time per frame rather than frequency itself.)   References = https://pmc.ncbi.nlm.nih.gov/articles/PMC2701968/?utm_source=chatgpt.com "
    },
    {
        "level": "6.",
        "title": "Data Size (Storage Requirements)",
        "content-type": "markdown",
        "content": ""
    },
    {
        "level": "6.1.",
        "title": "Single Image Size",
        "content-type": "markdown",
        "content": "512 KB to 1 MB  References = https://www.reddit.com/r/MedicalPhysics/comments/lvdlos/question_ct_file_size_calculation_in_raphex_2020/?rdt=43155"
    },
    {
        "level": "6.2.",
        "title": "Typical Study Size",
        "content-type": "markdown",
        "content": "300 MB to 1 GB for a standard dataset   References =  https://pmc.ncbi.nlm.nih.gov/articles/PMC6897007/"
    },
    {
        "level": "7.",
        "title": "Acquisition Device & Hardware Requirements",
        "content-type": "markdown",
        "content": ""
    },
    {
        "level": "7.1.",
        "title": "Equipment Used",
        "content-type": "markdown",
        "content": "1- CT Scanners 2- Carbon Dioxide (CO\u2082) Insufflators 3- Image Analysis Software  References = https://global.medical.canon/products/healthcare_it/clinical_application/ct_colon_analysis?utm_source=chatgpt.com"
    },
    {
        "level": "7.2.",
        "title": "Typical Manufacturers",
        "content-type": "markdown",
        "content": "General Electric (GE) Healthcare, Siemens Healthineers, Canon Medical Systems, Philips Healthcare, Bracco Imaging, Eisai Co., Ltd, Varay Laborix,  References = "
    },
    {
        "level": "8.",
        "title": "Common Clinical Applications",
        "content-type": "markdown",
        "content": ""
    },
    {
        "level": "8.1.",
        "title": "Primary Uses",
        "content-type": "markdown",
        "content": "Colorectal Cancer Screening   References = https://www.aafp.org/pubs/afp/issues/2021/0101/p55.html?utm_source=chatgpt.com"
    },
    {
        "level": "8.2.",
        "title": "Specialized Uses",
        "content-type": "markdown",
        "content": "Incomplete Colonoscopy Evaluation, Detection of Extracolonic Findings, Preoperative Planning      References =  https://pmc.ncbi.nlm.nih.gov/articles/PMC9191267/?utm_source=chatgpt.com"
    },
    {
        "level": "9.",
        "title": "Radiation & Safety Considerations",
        "content-type": "markdown",
        "content": ""
    },
    {
        "level": "9.1.",
        "title": "Ionizing Radiation",
        "content-type": "markdown",
        "content": "Yes   References = https://www.iaea.org/resources/rpop/health-professionals/radiology/computed-tomography/computed-tomography-colonography"
    },
    {
        "level": "9.2.",
        "title": "Radiation Dose (if applicable)",
        "content-type": "markdown",
        "content": "2-12 mSv   References =  https://www.iaea.org/resources/rpop/health-professionals/radiology/computed-tomography/computed-tomography-colonography"
    },
    {
        "level": "9.3.",
        "title": "Safety Concerns",
        "content-type": "markdown",
        "content": "Radiation Exposure: Small cancer risk, Bowel Perforation: Rare risk (0.005-0.03%), Dehydration: Risk from bowel prep    References =https://www.radiologyinfo.org/en/info/ct_colo "
    },
    {
        "level": "10",
        "title": "Preprocessing & Data Preparation",
        "content-type": "markdown",
        "content": ""
    },
    {
        "level": "10.1.",
        "title": "Common Preprocessing Steps",
        "content-type": "markdown",
        "content": "Image Acquisition Parameters, Image Post-Processing: Advanced techniques such as multiplanar reformation (MPR), virtual colonoscopy (VC), shaded surface display (SSD), and Raysum imaging enhance the visualization of colorectal lesions, aiding in accurate assessment.  References =  https://pmc.ncbi.nlm.nih.gov/articles/PMC4572757/"
    },
    {
        "level": "10.2.",
        "title": "Compression Methods (if any)",
        "content-type": "markdown",
        "content": "\"Lossless Compression: Methods like JPEG-LS are employed to reduce file size without sacrificing image quality, ensuring diagnostic information remains intact.  Lossy Compression: Techniques such as wavelet compression can achieve higher compression ratios; however, they may introduce artifacts\"   References = https://pmc.ncbi.nlm.nih.gov/articles/PMC8525863/"
    },
    {
        "level": "11.",
        "title": "Challenges & Limitations",
        "content-type": "markdown",
        "content": ""
    },
    {
        "level": "11.1.",
        "title": "Technical Challenges",
        "content-type": "markdown",
        "content": "Bowel Preparation Dependency, Insufflation Issues, Imaging Artifacts, Learning Curve References =  https://pubs.rsna.org/doi/abs/10.1148/rg.2020190078?utm_source=chatgpt.com"
    },
    {
        "level": "11.2.",
        "title": "Clinical Limitations",
        "content-type": "markdown",
        "content": "CTC may not be suitable for patients with active inflammatory bowel disease, recent bowel perforation, or those exceeding the weight limit of the CT scanner, Missed Flat Lesions, False Positives, Limited Therapeutic Capability, Extracolonic Findings, Radiation Exposure     References = https://www.radiologyinfo.org/en/info/ct_colo"
    },
    {
        "level": "prepration-meta-data-prepared_by",
        "title": "prepared_by",
        "content-type": "rawtext",
        "content": "Arman Gharehbahi"
    },
    {
        "level": "prepration-meta-data-confirmed_by",
        "title": "confirmed_by",
        "content-type": "rawtext",
        "content": ""
    },
    {
        "level": "prepration-meta-data-date_of_preparation",
        "title": "date_of_preparation",
        "content-type": "rawtext",
        "content": "2025-03-19"
    },
    {
        "level": "prepration-meta-data-planned_next_review",
        "title": "planned_next_review",
        "content-type": "rawtext",
        "content": ""
    },
    {
        "level": "prepration-meta-data-requires_completion",
        "title": "requires_completion",
        "content-type": "rawtext",
        "content": ""
    }
]